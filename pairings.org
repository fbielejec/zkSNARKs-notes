#+STARTUP: overview
#+latex_class_options: [14pt]

* Contents
:PROPERTIES:
:VISIBILITY:  all
:TOC:      :include all :ignore this :depth 2
:END:
:CONTENTS:
- [[#billinear-map][Billinear map]]
- [[#pairing][Pairing]]
  - [[#example-billinearity-of-a-pairing][Example: billinearity of a pairing]]
- [[#frobenius-endomorphism-frobenius-map][Frobenius endomorphism (Frobenius map)]]
  - [[#example][Example]]
- [[#trace-map-tr][Trace Map $Tr$]]
  - [[#example][Example]]
- [[#anti-trace-map-atr][Anti-trace map $aTr$]]
- [[#supersingular-curve][Supersingular curve]]
- [[#distortion-map-phi][Distortion map $\phi$]]
  - [[#example-414-pairings-for-beginners][Example 4.1.4 Pairings for beginners]]
  - [[#example-415-pairings-for-beginners][Example 4.1.5 Pairings for beginners]]
- [[#pairing-groups-mathbbg_1-and-mathbbg_2][Pairing groups $\mathbb{G}_1$ and $\mathbb{G}_2$]]
  - [[#example-g1-and-g2-pairing-groups][Example: G1 and G2 pairing groups]]
- [[#twisted-elliptic-curves][Twisted Elliptic Curves]]
  - [[#example-431-pairingsforbeginners][Example 4.3.1 PairingsForBeginners]]
  - [[#example-432-pairingsforbeginners][Example 4.3.2 PairingsForBeginners]]
- [[#divisors][Divisors]]
  - [[#rational-function-f-on-e][Rational function $f$ on $E$]]
  - [[#poles-and-zeros-of-a-rational-function-f-on-e][Poles and zeros of a rational function $f$ on $E$]]
  - [[#order-of-poles-and-zeros-of-a-rational-function-f-on-e][Order of poles and zeros of a rational function $f$ on $E$]]
  - [[#uniformizer][Uniformizer]]
  - [[#example-111-washington][Example 11.1 (Washington)]]
  - [[#function-divisors-principal-divisors][Function divisors (principal divisors)]]
  - [[#principal-divisors-properties][Principal divisors: properties]]
  - [[#example-principal-divisor-divisor-of-a-function][Example: Principal divisor (divisor of a function)]]
  - [[#example-principal-divisor][Example: Principal divisor]]
  - [[#connection-between-point-addition-on-an-elliptic-curve-and-divisors][Connection between point addition on an elliptic curve and divisors]]
  - [[#example-finding-a-divisor-of-a-function][Example: Finding a divisor of a function]]
  - [[#example-311-pairingsforbeginners][Example 3.1.1 (PairingsForBeginners)]]
  - [[#example-501-pairingsforbeginners][Example 5.0.1 (PairingsForBeginners)]]
- [[#the-weil-pairing][The Weil Pairing]]
  - [[#example-511-constructing-the-weil-pairing][Example 5.1.1: constructing the Weil pairing]]
- [[#teaser-pairings-in-zk][Teaser: pairings in ZK]]
  - [[#example-1][Example 1]]
  - [[#example-2][Example 2]]
- [[#additional-materials][Additional materials]]
:END:

* Billinear map
An elliptic curve pairing is a function (a map) that takes a pair of points on an elliptic curve and returns an element of some other group, called the target group, preserving certain algebraic properties (billinearity, non-degeneracy and efficiency).

$e: G_0 \times G_1 \rightarrow G_T$

=Billinearity=

Let's take points $P,Q \in G_0$ and $S,T \in G_1$.
Billinearity means that these two properties hold for $e$:
- $E(P+Q,S)=e(P,S) \times e(Q,S)$
- $E(P,S+T)=e(P,S) \times e(P,T)$

Let $a,b$ be scalars. If $e$ is a billinear map we can derive these properties:
\begin{equation*}
e(aP,bS) = e\left( (a-1)P + P,bS \right) = e\left( (a-1)P, bS \right) \times e\left( P,bS \right) = e\left( (a-2)P + P,bS \right) \times e\left( P,bS \right) = e\left( (a-2)P, bS \right) \times e\left( P,bS \right)^{2} = \dots = e\left( P,bS \right)^{a}
\end{equation*}

\begin{equation*}
e\left( P,bS \right)^{a} = e \left( P, (b-1)S+S \right)^{a} = \left[ e \left( P, (b-1)S \right) \times e \left( P, S \right) \right]^{a}= \dots =e \left( P, S \right) ^{ab}
\end{equation*}

\begin{equation*}
e \left( P, S \right) ^{ab}= \dots = e \left( P, abS \right)= \dots = e \left( abP, S \right)
\end{equation*}

$e(P,S)^{ab} = e(aP,bS)$

=Non-degeneracy=

$\forall g_0 \in G_0,  g_1 \in G_1 \quad e \left( g_0, g_1 \right) \neq 1$
where $1$ is the identity element in the target group, $g_0,g_1$ are the generators of groups $G_0,G_1$

=Efficiency (computability)=

There exists an efficient algorithm to compute $e$.
* Pairing
=Definition=

Pairing is a [[BilinearMap][bilinear map]] on an abelian group M taking values in some other abelian group R:

$<\cdot ,\cdot>: M \times M \rightarrow R$

In the cryptographic setting it is advantageous to relax the condition that the two arguments come from the same group and instead work with:

$e : \mathbb{G}_1 \times \mathbb{G}_2 \rightarrow \mathbb{G}_T$

Let $F_{q^k}$ be some [[PrimeFieldExtension][finite field extension]] of $F_q$ with $k\geq 1$. The groups $\mathbb{G}_1$ and $\mathbb{G}_2$ are defined in $E(F_{q^k})$ and the /target group/ $\mathbb{G}_T$ is defined in the multiplicative group $F_{q^k}^{*}$

** Example: billinearity of a pairing
#+BEGIN_SRC sage :session . :exports both
q=7691
Fq=GF(q)
E_Fq=EllipticCurve(Fq, [0,1])
E_Fq

# constructing F_q^2 extension field
Fqx.<x> = Fq[]
#Fqx

# modulus is an irreducible polynomial in Fq such that x is it's root in Fq^2
Px=Fqx(x^2+1)
#Px(x)

Fq2.<x> = GF(q^2, name='x', modulus=Px)
#Fq2

# now we define the elliptic curve over the extension field
E_Fq2=EllipticCurve(Fq2,[0,1])
#E_Fq2

P=E_Fq(2693, 4312)
Q=E_Fq2(633*x + 6145, 7372*x + 109)

E_Fq_order = E_Fq.order()
E_Fq_order.factor()

# extension group order is equal to the square of the "vanilla" group order
E_Fq2_order = E_Fq2.order()
E_Fq2_order.factor()

# P and Q were especially chosen to be in different subgroups of the same prime order r=641)
P.order()
#P*641 # gives point at infinity

Q.order()
#Q*641 # gives point at infinity
r = 641

# --- billinearity
# take any a and b scalars \in Zr
a = 403; b = 135
#a*P
#b*Q

# Weil pairing of P,Q e(P,Q) is:
ePQ = Fq2(6744*x + 5677)

# pairing lies in the roots of unity subgroup of the extension field F_{q^2}: e(P,Q)^r = 1
ePQ^r

# e(aP,Q) == e(P,Q)^a
ePQ^a
# e(P,bQ) == e(P,Q)^b
ePQ^b

# e(aP,bQ) == e(P,Q)^{ab mod r}
ePQ^((a*b) % 641)
#+END_SRC

#+RESULTS:
: Elliptic Curve defined by y^2 = x^3 + 1 over Finite Field of size 7691
: 2^2 * 3 * 641
: 2^4 * 3^2 * 641^2
: 641
: 641
: 1
: 3821*x + 7025
: 248*x + 5
: 2719*x + 2731

---

*NOTE*

Since $e(P,Q) \neq 1$ in the roots of unity subgroup of $F_{q^2}$, $e([a]P,[b]Q)$ is trivial (equal to $\mathcal{O}$) only if $r | ab$, which implies that either $r|a$ or $r|b$, which in turn means that eiter (or both) $[a]P$ or $[b]Q$ are equal to $\mathcal{O}$.
This condition guarantees non-trivial (meaning $e([a]P,[b]Q) \neq 0$) pairings for non-trivial arguments. This property is called *non-degeneracy* of the pairing.

---

* Frobenius endomorphism (Frobenius map)
=Definition=

Let $F_q$ be a finite field of characteristic $q$ and $E(F_q)$ an elliptic curve over that field.
*Frobenius endomporphism* is a map $\pi$ such that:

$\pi: E(F_q) \rightarrow E(F_q): \left\{\begin{array}{ll}
                                         (x,y)  \mapsto (x^p,y^p) \\
                                         \mathcal{O} \mapsto \mathcal{O}
                                        \end{array}\right}$

** Example
#+begin_src sage :session . :exports both
q = 5  # Define the characteristic, q is a prime
F = FiniteField(q)
E = EllipticCurve(F, [4, 1])  # Define the curve y^2 = x^3 + 4x + 1 over GF(5)

# Define a point on the curve
P = E.random_point()

# Print the original point
print(f"Original point P: {P}")

# Apply the Frobenius endomorphism
x, y = P.xy()
Frobenius_P = E([x^q, y^q])

# Print the point after applying Frobenius endomorphism
print(f"Point after Frobenius endomorphism π(P): {Frobenius_P}")
#+end_src

#+RESULTS:
: Original point P: (3 : 0 : 1)
: Point after Frobenius endomorphism π(P): (3 : 0 : 1)

* Trace Map $Tr$
- p53 PairingsForBeginners

=Definition=

For an elliptic curve $E$ defined over an extension field $\mathbb{F}_{q^k}$, the trace map $\text{Tr}$ of a point $P \in E(\mathbb{F}_{q^k})$ is defined as:

$\text{Tr}(P) = \sum_{i=0}^{k-1} \pi^{i}(P) = P + \pi(P) + \pi^2(P) + \cdots + \pi^{k-1}(P)$

where $\pi$ is the [[*Frobenius endomorphism][Frobenius endomorphism]], defined by raising the coordinates of each point to the q-th power:

$\pi((x, y)) = (x^q, y^q)$

Trace map is actually a homomorphism and it sends all torsion points into one of the subgroups of the r-torsion (the base field subgroup):

$Tr: E(F_q^k) \rightarrow E(F_q)$

** Example
#+BEGIN_SRC sage :session . :exports both
q=11
F=GF(q)
E=EllipticCurve(F,[7,2])

E_order=E.order()
print(f"E(F_{q}) order: {E.order()}")

E_order.factor()

r=7
torsion_points = [P for P in E.points() if r * P == E(0)]

print(f"{r}-torsion points of E(F_{q}): {torsion_points}")

# embedding degree
k = 1
while not (r.divides(q^k - 1)):
    k += 1
print(f"Embedding degree of E_F{q}: {k}")

# extending E(F_q) to E(F_q^k)
# ring of polynomials with coefficients in Fq:
Fx.<x> = F[]
# irreducible polynomial on the ring
f=Fx(x^3+x+4)
print(f"Polynomial f(x)= {f} from {Fx} is irreducible in F: {f.is_irreducible()}")

# Construct F_q^k by dividing all polynomials in the ring over F by the irreducible polynomial P_mod:
Fqk.<u> = GF(q^k, name = 'u', modulus = f)
print(f"F_{q}^{k} has order: {Fqk.order()}")

# u is the root of P_mod in F_q^k
print(f"f(u)={f(u)}")

# Extending E(F_q) to F_q^k:
E_Fqk = EllipticCurve(Fqk, [7,2])
print(f"E(F_{q}^{k}) has order: {E_Fqk.order()}")

# Full r-torsion
full_torsion_points = [P for P in E_Fqk.points() if r * P == E_Fqk(0)]
print(f"Cardinality of the full {r}-torsion E[F_{q}^{k}]({r}): {len(full_torsion_points)}")

def trace_map(P):
        return sum(E_Fqk((P[0]^(q^i), P[1]^(q^i))) for i in range(k))

P = E_Fqk.random_point()
trace_P=trace_map(P)

# The trace map takes point P in E(F_q^k) to the r-torsion E(F_q)[r]:
print(f"Tr({P})={trace_P} is in the {r}-torsion E[F_{q}]: {E(trace_P) in torsion_points}")

# Notation on p 53
Q=E_Fqk(x^481 % f,x^1049 % f)
trace_map(Q)
print(f"Tr({Q})={trace_map(Q)} is in the {r}-torsion E[F_{q}]: {E(trace_map(Q)) in torsion_points}")
#+END_SRC

#+RESULTS:
#+begin_example
E(F_11) order: 7
7
7-torsion points of E(F_11): [(0 : 1 : 0), (7 : 3 : 1), (7 : 8 : 1), (8 : 3 : 1), (8 : 8 : 1), (10 : 4 : 1), (10 : 7 : 1)]
Embedding degree of E_F11: 3
Polynomial f(x)= x^3 + x + 4 from Univariate Polynomial Ring in x over Finite Field of size 11 is irreducible in F: True
F_11^3 has order: 1331
f(u)=0
E(F_11^3) has order: 1372
Cardinality of the full 7-torsion E[F_11^3](7): 49
Tr((8*u + 8 : 9*u^2 + 7*u + 4 : 1))=(10 : 4 : 1) is in the 7-torsion E[F_11]: True
(8 : 8 : 1)
Tr((4*u^2 + 7*u + 4 : 10*u^2 + 2*u + 6 : 1))=(8 : 8 : 1) is in the 7-torsion E[F_11]: True
#+end_example

* Anti-trace map $aTr$

=Definition=

Anti-trace map maps any $P \in E[r]$ to the "trace zero" subgroup $\mathbb{G}_2$:

$aTr: P \rightarrow P^{'} = [k]P - Tr(p)$

* Supersingular curve
=Definition=

An elliptic curve $E$ is called /supersingular/ if $\#E(F_q) = q+1$.
A curve which is not supersingular is called ordinary.

Supersingular curves come equipped with a [[*Distortion map $\phi$][Distortion map]] $\phi$, i.e. a non-$F_q$-rational map that takes a point in $E(F_q)$ to a point in $E(F_q^k)$.
* Distortion map $\phi$
** Example 4.1.4 Pairings for beginners
#+BEGIN_SRC sage :session . :exports both
q=59
F=GF(q)
E_F=EllipticCurve(F, [0,1])
E_order=E_F.order()

print(f"E(F_{q}) order: {E_order}")
print(f"E(F_{q}) is supersingular: {E_order == q+1}")
#r=5
#k=2
Fi.<i> = F[]
Fi
f=Fi(i^2+1)
print(f"Polynomial f(x)={f} from {Fi} is irreducible: {f.is_irreducible()}")

F_ext = F.extension(f, name = "i")
#[p for p in F_ext]
E_ext=EllipticCurve(F_ext, [0,1])
xi = E_ext(24*i+29,23*i)
# TODO : cube root of unity?
xi

def distortion_map(P):
        return (xi[0]*P[0], P[1])

# \phi^3 is equivalent to the identity map:
distortion_map(distortion_map(distortion_map((36,37*i))))
#+END_SRC

#+RESULTS:
: E(F_59) order: 60
: E(F_59) is supersingular: True
: Univariate Polynomial Ring in i over Finite Field of size 59
: Polynomial f(x)=i^2 + 1 from Univariate Polynomial Ring in i over Finite Field of size 59 is irreducible: True
: (24*i + 29 : 23*i : 1)
: (36, 37*i)

** Example 4.1.5 Pairings for beginners
#+BEGIN_SRC sage :session . :exports both
q=59
F=GF(q)
E_F=EllipticCurve(F, [1,0])

Fi.<i> = F[]
f=Fi(i^2+1)
F_ext = F.extension(f, name = "i")
E_ext=EllipticCurve(F_ext, [1,0])

def distortion_map(P):
        return (-P[0], i*P[1])

E_ext(distortion_map(distortion_map(distortion_map(distortion_map((25,30))))))

E_ext(distortion_map(distortion_map(distortion_map(distortion_map((31*i+51,34*i+49))))))
#+END_SRC

#+RESULTS:
: (25 : 30 : 1)
: (31*i + 51 : 34*i + 49 : 1)

* Pairing groups $\mathbb{G}_1$ and $\mathbb{G}_2$

=Definition: pairing groups G_1 and G_2=

Given the [[FrobeniusEndomorphism][Frobenius map]] definition we can characterize two important subgroups of the full r-torsion group $E[r]$.

The first subgroup $\mathbb{G}_1[r]$ (abbreviated $\mathbb{G}_1$ when $r$ is implicit) is defined as the one on which the [[*Frobenius endomorphism][Frobenius endomorphism]] acts trivially:

$\mathbb{G}_1[r] := \{ (x,y) \in E[r] \hspace{0.5em} | \hspace{0.5em} \pi(x,y) = (x,y) \}$

It can be shown that $\mathbb{G}_1$ is precisely the r-torsion group $E(F_p)[r]$ of the unextended elliptic curve defined over the prime field $F_p$.

The second subgroup $\mathbb{G}_2[r]$ is defined as follows:

$\mathbb{G}_2[r] := \{ (x,y) \in E[r] \hspace{0.5em} | \hspace{0.5em} \pi(x,y) = [p](x,y) \}$

---

*NOTE*

[[TraceMap][Trace Map]] of all of the points in $\mathbb{G}_2[r]$ is $\mathcal{O}$ (vanishes):

$\forall P \in \mathbb{G}_2[r] \hspace{0.5em}  Tr(P)=\mathcal{O}$

Hence it is also reffered to as the *trace zero* subgroup.
/(result attributed to Dan Boneh, see S.D Galbraith, Pairings, volume 317, Lemma IX.16)/

---

If $E(F)$ is an elliptic curve and $r$ is the largest prime factor of the curves order we call $\mathbb{G}_1[r]$ and $\mathbb{G}_2[r]$ *pairing groups* (also written $\mathbb{G}_1$ and $\mathbb{G}_2$).

** Example: G1 and G2 pairing groups
#+BEGIN_SRC sage :session . :exports both
# consider the curve E1,1(F5)
q=5
F5=GF(q)
E11_F5=EllipticCurve(F5, [1,1]);
print(f"Order of the elliptic curve: {E11_F5.order()}")

# E11_F5 has the embedding degree k = 2 with respect to r = 3
r=3
for k in range(1,q):
  if r.divides(q^k-1):
    print("Embedding degree k(r=3) =",k) ; break

# 0. Begin by finding the 3-torsion of the unextended curve over the prime field
unextended_3torsion = []
for p in E11_F5:
  if p*3 == E11_F5(0):
    unextended_3torsion.append(p);

print(unextended_3torsion)

# full r-torsion group will be in the E(Fq^k(r))=E(Fq^2)
# 1. Define the extension field
# 1.1 Find a polynomial of order m=2 irreducible in F5
F5x.<x> = F5[]
P_MOD = F5x(x^2+2)
P_MOD.is_irreducible()

# 1.2 Construct the extension field
F5_2x=GF(q^2, name='x', modulus=P_MOD)

# 2. Define the elliptic curve on the extension field
E_F5_2 = EllipticCurve(F5_2x, [1,1])

# 3. Full 3-torsion group (it's in the E_F5_2 group because embedding degree is k=2)
full_torsion_group = [P for P in E_F5_2 if r * P == E_F5_2(0)]
print("Full r-torsion group:", full_torsion_group)

# 4. G1 subgroup
G1 = []
for P in full_torsion_group:
  # we have to use the Frobenius endomorphism of the underlying field
  PiP = E_F5_2([a.frobenius() for a in P]) # \pi(P)
  if P == PiP:
    G1.append(P)

print('G1=', G1)

# as expected G1 is identical to the 3-torsion sub-group of the unextended elliptic curve (see 0.)

# 5. G2 subgroup
G2 = []
for P in full_torsion_group:
  PiP = E_F5_2([a.frobenius() for a in P]) # \pi(P)
  pP = q*P # [5]P
  if pP == PiP: # \pi(P) = [r]P
    G2.append(P)

print('G2 =', G2)

#+END_SRC

#+RESULTS:
: Order of the elliptic curve: 9
: Embedding degree k(r=3) = 2
: [(0 : 1 : 0), (2 : 1 : 1), (2 : 4 : 1)]
: True
: Full r-torsion group: [(0 : 1 : 0), (1 : x : 1), (1 : 4*x : 1), (2 : 1 : 1), (2 : 4 : 1), (2*x + 1 : x + 1 : 1), (2*x + 1 : 4*x + 4 : 1), (3*x + 1 : x + 4 : 1), (3*x + 1 : 4*x + 1 : 1)]
: G1= [(0 : 1 : 0), (2 : 1 : 1), (2 : 4 : 1)]
: G2 = [(0 : 1 : 0), (1 : x : 1), (1 : 4*x : 1)]

* IN-PROGRESS Twisted Elliptic Curves
** Example 4.3.1 PairingsForBeginners
Every twist has a degree $d$ which  which tells us the extension field of $F_q$ where $E$ and $E'$ become isomorphic (with respect to $\psi$ and $\psi^{-1}$).

$d$ is also the degree of the field of definition of $E'$ as a subfield of $F_{q^k}$, i.e. a degree $d$ twist $E'$ of $E$ will be defined over $F_{q^{k/d}}$.

In this example, $k=2$ and $E'$ is defined over $F_q$, so we are using a $d = 2$ twist, called a quadratic twist. Instead of performing the computations in the group $\mathbb{G}_2$, which require computations in the extension field $F_{q^2 }$, but instead we can use $\psi^{-1}$ to perform them in the $E'(F_q)$ before mapping the result back with the $\psi$.

$\psi^{-1}$ maps elements in $\mathbb{G}_2 \in E(F_{q^k})[r] = E(F_{q^6})[r]$ to elements in $E'(F_{q^{k/d}})[r] = E'(F_q)[r]$.

#+BEGIN_SRC sage :session . :exports both
q=11
F=GF(q)
E=EllipticCurve(F, [0, 4])
E_twist=EllipticCurve(F, [0, -4])

print(f"elliptic curve E: {E}")
print(f"twisted elliptic curve E': {E_twist}")

r=3
r_torsion=[P for P in E.points() if r*P == E(0)]
r_torsion_twist=[P for P in E_twist.points() if r*P == E_twist(0)]

k=2
Fi.<i> = F[]
f=Fi(i^k+1)
F_ext = F.extension(f, name = "i")
E_ext=EllipticCurve(F_ext, [0, 4])
E_ext_twist=EllipticCurve(F_ext, [0, -4])
full_torsion=[P for P in E_ext.points() if r*P == E_ext(0)]
full_torsion_twist=[P for P in E_ext_twist.points() if r*P == E_ext_twist(0)]

G1=r_torsion
print(f"G1 pairing subgroup of E[{r}]: {G1}")

G1_twist=r_torsion_twist
print(f"G1' pairing subgroup of E'[{r}]: {G1_twist}")

def trace_map(P, EC):
  return sum(EC((P[0]^(q^i), P[1]^(q^i), P[2])) for i in range(k))

# G2 is the "trace zero" subgroup
G2=[P for P in full_torsion if trace_map(P, E_ext) == E_ext(0)]
print(f"G2 pairing subgroup of E[{r}]: {G2}")

G2_twist=[P for P in full_torsion_twist if trace_map(P, E_ext_twist) == E_ext_twist(0)]
print(f"G2' pairing subgroup of E'[{r}]: {G2_twist}")

i=F_ext.gen()
def psi_inv(P):
  return (-P[0], i*P[1], P[2])

# \psi^{-1} : E[r] -> E[r]'
# the map works for the entire curve group
# but if we restrict the psi_inv to G2 it actually maps between curve elements in Fq^2 to Fq
for P in G2:
  x,y,z = psi_inv(P)
  print(f"{P} -> {(x, y, z)}")

# \psi : E'[r] -> E[r]
def psi(P):
  return (-P[0], -P[1]*i, P[2])

# similar, this could be the entire twisted curve: E_ext_twist.points()
for P in full_torsion_twist:
  x,y,z = psi(P)
  print(f"{P} -> {(x, y, z)}")

#+END_SRC

#+RESULTS:
#+begin_example
elliptic curve E: Elliptic Curve defined by y^2 = x^3 + 4 over Finite Field of size 11
twisted elliptic curve E': Elliptic Curve defined by y^2 = x^3 + 7 over Finite Field of size 11
G1 pairing subgroup of E[3]: [(0 : 1 : 0), (0 : 2 : 1), (0 : 9 : 1)]
G1' pairing subgroup of E'[3]: [(0 : 1 : 0), (3 : 1 : 1), (3 : 10 : 1)]
G2 pairing subgroup of E[3]: [(0 : 1 : 0), (8 : i : 1), (8 : 10*i : 1)]
G2' pairing subgroup of E'[3]: [(0 : 1 : 0), (0 : 2*i : 1), (0 : 9*i : 1)]
(0 : 1 : 0) -> (0, i, 0)
(8 : i : 1) -> (3, 10, 1)
(8 : 10*i : 1) -> (3, 1, 1)
(0 : 1 : 0) -> (0, 10*i, 0)
(0 : 2*i : 1) -> (0, 2, 1)
(0 : 9*i : 1) -> (0, 9, 1)
(3 : 1 : 1) -> (8, 10*i, 1)
(3 : 10 : 1) -> (8, i, 1)
(2*i + 4 : 1 : 1) -> (9*i + 7, 10*i, 1)
(2*i + 4 : 10 : 1) -> (9*i + 7, i, 1)
(9*i + 4 : 1 : 1) -> (2*i + 7, 10*i, 1)
(9*i + 4 : 10 : 1) -> (2*i + 7, i, 1)
#+end_example

** Example 4.3.2 PairingsForBeginners
#+BEGIN_SRC sage :session . :exports both
q=103
F=GF(q)
E=EllipticCurve(F, [0,72])
E_order=E.order()

[r for r in divisors(E_order) if r.is_prime()]

# select r as the largest prime divisor of the curve's order
r=7

k = 1
while not (r.divides(q^k - 1)):
    k += 1
k

r_torsion=[P for P in E.points() if r*P== E(0) ]
#r_torsion

# define the extension Fq^k
R.<u> = F[]
mod_poly=R(u^6+2)
#mod_poly.is_irreducible()
Fqk=F.extension(modulus=mod_poly, name = 'u')
Fqk

EFqk=EllipticCurve(Fqk, [0,72])
#full_r_torsion=[P for P in EFqk.points() if r*P == EFqk(0) ] #NOTE: gets intractable

def trace_map(P):
        return sum(EFqk((P[0]^(q^i), P[1]^(q^i))) for i in range(k))

# trace zero subgroup G2 is generated by this point:
G=EFqk(35*u^4,42*u^3)

trace_map(G*5)

# NOTE: we should probably go all the way to q^k but the group is visible already
G2=set([i*G for i in (1..q) ])
G2

u=Fqk.gen()

# d=6
E_twist=EllipticCurve(F, [0,72*u^6])
E_twist

r_torsion_twist = [p for p in E_twist.points() if r*p == E_twist(0)]
r_torsion_twist

# \psi^{-1} : E[r] -> E[r]'
def psi_inv(P):
  return (u^2*P[0], u^3*P[1], P[2])

# back and forth isomorphism maps elements in G2=E(F_q^k)[r] to elements in E'(F_q^{k/d})[r] = E'(Fq)[r]
# gaining advantage of working in Fq instead of Fq^6
for P in G2:
  x,y,z = psi_inv(P)
  print(f"{P} -> {(x, y, z)}")

# \psi : E'[r] -> E[r]
def psi(P):
  return (P[0]/u^2, P[1]/u^3, P[2])

for P in r_torsion_twist:
  x,y,z = psi(P)
  print(f"{P} -> {(x, y, z)}")

#+END_SRC

#+RESULTS:
#+begin_example
[2, 3, 7]
6
Finite Field in u of size 103^6
(0 : 1 : 0)
{(0 : 1 : 0),
 (3*u^4 : 42*u^3 : 1),
 (3*u^4 : 61*u^3 : 1),
 (35*u^4 : 42*u^3 : 1),
 (35*u^4 : 61*u^3 : 1),
 (65*u^4 : 42*u^3 : 1),
 (65*u^4 : 61*u^3 : 1)}
Elliptic Curve defined by y^2 = x^3 + 62 over Finite Field of size 103
[(0 : 1 : 0),
 (33 : 19 : 1),
 (33 : 84 : 1),
 (76 : 19 : 1),
 (76 : 84 : 1),
 (97 : 19 : 1),
 (97 : 84 : 1)]
(35*u^4 : 61*u^3 : 1) -> (33, 84, 1)
(65*u^4 : 61*u^3 : 1) -> (76, 84, 1)
(0 : 1 : 0) -> (0, u^3, 0)
(3*u^4 : 42*u^3 : 1) -> (97, 19, 1)
(35*u^4 : 42*u^3 : 1) -> (33, 19, 1)
(65*u^4 : 42*u^3 : 1) -> (76, 19, 1)
(3*u^4 : 61*u^3 : 1) -> (97, 84, 1)
(0 : 1 : 0) -> (0, 51*u^3, 0)
(33 : 19 : 1) -> (35*u^4, 42*u^3, 1)
(33 : 84 : 1) -> (35*u^4, 61*u^3, 1)
(76 : 19 : 1) -> (65*u^4, 42*u^3, 1)
(76 : 84 : 1) -> (65*u^4, 61*u^3, 1)
(97 : 19 : 1) -> (3*u^4, 42*u^3, 1)
(97 : 84 : 1) -> (3*u^4, 61*u^3, 1)
#+end_example

* IN-PROGRESS Divisors
=Definition: divisor=

A *divisor* $D$ on $E$ (elliptic curve) is a way to denote a multi set of points on $E$, written as the formal sum:

$\text{D} = \sum_{P \in E} n_p (P)$

where:
- $n_P \in \mathbb{Z}$ are the coefficients associated with points),
- only finitely many $n_P$ are nonzero (i.e. the sum is finite)

---

<<PrimeDivisors>> *NOTE: prime divisors*

The standard parentheses $(\cdot)$ around the P's and the absence of square parentheses $[\cdot]$ around the $nP$'s is what differentiates the formal sum in a divisor from an actual [[DivisorSum][sum of points]] (i.e. using the group law) on E.

The notation $(P)$ in the divisor is a formal symbol representing the *prime divisor* associated with the point $P$.
For $P \in E$, $(P)$ is a divisor with coefficient $1$ at $P$ and 0 elsewhere (a degree-1 divisor, see also [[DivisorDegree][divisor degree]] for a definition)).

In fact every point $P \in E$, gives rise to a degree-1 divisor and the expression $(P)$ is exactly that, a degree-1 divisor.

While every point defines a divisor, *not every divisor comes from a point*, rather they are linear combinations of points.
For example $D = (P) - (Q)$ is not a single point but a difference.

---

<<DivisorDegree>> =Definition: divisor degree=

The degree of a divisor $D$ is the sum of it's coefficients:

$\text{deg}(D) = \sum_{P \in E} n_P$

=Definition: divisor support=

The support of $D$ is the set:

$\textit{supp}(D)=\{P \in E(\bar{F}_q) \hspace{.5em} : \hspace{.5em} n_p \neq 0\}$

<<DivisorSum>> =Definition: divisor sum=

The sum function simply uses the group law on $E$ to add up the points:

$\text{sum}(\sum_{j} a_j (P_j))=\sum_{j} a_j [P_j ]$

=Definition: divisors equivalence=

Two divisors $D_1$ and $D_2$ are are said to be linearly equivalent if their difference $D_1 - D_2$ is a principal divisor.

=Definition: principal divisor=

*Principal Divisor:* A divisor of a rational function $f \in \mathbb{F}_q(E)$, given by:
$\text{div}(f) = \sum_{P \in E} \text{ord}_P(f) (P)$,

where:
- $\text{ord}_P(f)$ is the order of vanishing (or pole) of $f$ at $P (see

=Example=

If $D = 3(P) - 2(Q)$, then:
- $\deg(D) = 3 + (-2) = 1$
- the support is $\{P, Q\}$

#+BEGIN_SRC sage :session . :exports both
F = FiniteField(103)
E = EllipticCurve(F, [20, 20])
P = E(26,20); Q = E(63,78);

D1 = E.divisor([(3,P), (2,Q)])
# same as
D1 = 3*E.divisor(P) - 2*E.divisor(Q)
D1

degree_D = sum([D1.coefficient(p) for p in [P,Q] ])
print("Degree of D:", degree_D)

support_D = D1.support()
print("Support of D:", support_D)
#+END_SRC

#+RESULTS:
: 3*(x - 26*z, y - 20*z) - 2*(x + 40*z, y + 25*z)
: Degree of D: 1
: Support of D: [(26 : 20 : 1), (63 : 78 : 1)]

** DONE Rational function $f$ on $E$

---

*NOTE*

Rational function (algebraic term) is sometimes in literature refered to as the /meromorphic function/ (a term from complex analysis).

---

=Definition=

A *rational function* $f$ on an elliptic curve $E$ is a ratio of polynomial functions defined on $E$ that is "well-defined" at all but finitely many points $P \in E$.

More formally, let $E$ be an elliptic curve defined over a field $F$.
A *rational function* $f: E \to F$ is a function that can be expressed as:

$f(P) = \frac{g(P)}{h(P)}$

where:
-  $g$ and $h$ are polynomials in the coordinate ring $\mathbb{F}_q[E]$ (i.e., polynomials in $x$ and $y$ satisfying curve's $E$ equation $y^2 = x^3 + ax + b$).
- For points $P \in E$ $h(P)$ is not identically zero (not zero everywhere on the curve).

=Rational Functions Field vs. Coordinate Ring=

The *function field* $\mathbb{F}_q(E)$ (field of rational functions on $E$) is the fraction field of $\mathbb{F}_q[E]$.
While $\mathbb{F}_q[E]$ contains only polynomials (e.g., $f(x,y)=x$, $f(x,y)=y$ or $f(x,y)=x^2y$) $\mathbb{F}_q(E)$ includes ratios like $\frac{x^2 + y}{y - 1}$.

---

<<CoordinateRing>> *NOTE*

The *coordinate ring* $\mathbb{F}_q[E]$ of an elliptic curve $E$ over a finite field $\mathbb{F}_q$ is an algebraic object consists of all polynomial functions $f(x, y)$ that are "allowed" on $E$ (satisfy the curve's equation).

More formally:

Consider an elliptic curve $E$ defined by a Weierstrass equation:

$E: y^2 + a_1xy + a_3y = x^3 + a_2x^2 + a_4x + a_6$,

where:
- $a_i \in \mathbb{F}_q$

Then:

$\mathbb{F}_q[E] := \frac{\mathbb{F}_q[x, y]}{(y^2 + a_1xy + a_3y - x^3 - a_2x^2 - a_4x - a_6)}$

where:
- $\mathbb{F}_q[x, y]$ is the ring of polynomials in two variables.
- The denominator $(y^2 + \cdots)$ is the *ideal* generated by the Weierstrass equation.
- This quotient ring means we treat the curve equation as $0$, so $y^2 \equiv x^3 + \cdots$ in $\mathbb{F}_q[E]$.

---

=Example=

A typical rational function would be:

$f(P) = \frac{y}{x - c}$

where:
 - $c$ is some constant.

This function is rational because $y$ is a regular function, and it has a pole (see [[*Poles and zeros of a rational function f on E][Poles and zeros of a rational function f on E]]) at the point where $x = c$.

** DONE Poles and zeros of a rational function $f$ on $E$
Once again a rational function is a function which can be expressed as:

$f = \frac{g}{h}$,

where:
- $g$ and $h$ are polynomials in the quotient ring $\mathbb{F}_q[E]$ (see [[CoordinateRing][Coordinate Ring]])

In the [[*Rational function $f$ on $E$][Rational function $f$ on $E$]] we said that $f$ is /"well defined"/ everywhere but in a finite number of points.
The points where $f$ is *undefined* can be classified as *zeros* or *poles* of $f$.

=Definition: zero (point of vanishing)=

A zero is where $f$ *vanishes* (i.e., $f(P) = 0$).

=Example: zero=

Consider the rational function $f(x,y)=(x-a)$.
$f$ has a zero at $P=(a,b)$ becasue $f(P)=0$.

=Definition: pole=

A pole is where $f$ is undefined ("blows up").
$f$ may be undefined at points where $h(P) = 0$ (i.e., the denominator vanishes).
$f(P)$ is then undefined because the denominator vanishes while the numerator does not i.e.:

$\lim_{h(P) \to 0} \frac{g(P)}{h(P)} = \infty$

=Example: pole=

Let $f = \frac{1}{y}$ on $E: y^2 = x^3 + x$,
$f$ has a pole at $P = (a, 0)$ (point where $y = 0$).

Finally we say that $f$ is *well-defined* at the points where $f$ has neither a zero nor a pole.

** DONE Order of poles and zeros of a rational function $f$ on $E$

From [[*Poles and zeros of a rational function $f$ on $E$][Poles and zeros of a rational function]] we know that function $f$ has a zero at a point $P$ if it takes the value $\mathcal{O}$ at $P$, and it has a pole at $P$ if it takes the value $\infty$ at $P$.
However, we need more refined information, namely the *order** of the zero or pole.

=Definition: order=

For a rational function $f \in F_q(E)^{*}$ on an elliptic curve $E$, the *order* of $f$ at a point $P \in E$, denoted $\text{ord}_P(f)$, is an integer that measures how $f$ behaves near $P$.
It encodes how many times the function $f$ vanishes (has a zero) or goes to infinity (has a pole) at that point (see [[*Poles and zeros of a rational function $f$ on $E$][Poles and zeros of a rational function $f$ on $E$]]).

=Definition: order of a zero (order of vanishing)=

If $f$ has a zero of order $k$ at $P=(x_P,y_P)$ then $f(P) = 0$ and $f$ can be expressed locally around $P$ as:

$f(x,y) = (x - x_P)^k \cdot g(x, y)$

where:
 - $g(x,y)$ is a regular function and
 - $g(P) \neq 0$.

=Example=

Consider the rational function $f(x,y)=(x-a)^k$ for some $k>0$.
$f$ has a zero of multiplicity $k$ at $P=(a,b)$, thus:

$\text{ord}_P(f) = k$.

=Definition: order of a pole=

If $f$ has a pole of order $m$ at $P$, it means that $f(P)$ is undefined (intuitively we can think of it as infinite), and $f$ can be expressed as:

$f(x,y) = \frac{(x - x_{P})^{-m}}{h(x, y)}$

where:
- $h$ is a regular function and
- $h(P) \neq 0$.

=Example=

Consider $f(x, y) = \frac{1}{(x-a)^k}$ for some $k>0$.
This function has a pole at $P=(a,b)$ of multiplicity $k$:

$\text{ord}_P(g) = -k$,

---

*NOTE: How to Compute the Order*

1. *For zeros*:
   - Factor $f$ locally near $P=(a,b)$ using taylor expansion. If $f = (x - a)^k \cdot g(x)$, where $g(a) \neq 0$, then $\text{ord}_{(a,b)}(f) = k$.

2. *For poles*:
   - If $f = \frac{g}{h}$, then $\text{ord}_P(f) = \text{ord}_P(g) - \text{ord}_P(h)$.
   - If $h$ vanishes at $P$ but $g$ does not $\text{ord}_P(f) = -\text{ord}_P(h)$.

3. *At infinity (for Weierstrass form)*:
   - The point $\mathcal{O} = (0:1:0)$ is treated with homogeneous coordinates. For $f = \frac{x}{y}$, $\text{ord}_\mathcal{O}(f) = -1 - 1 = -2$ (double pole).

---

** IN-PROGRESS Uniformizer
It can be shown that there is a function $u_P$ called a *uniformizer* at $P$ such that:

# $U(P)=0$

and such that every function f(x,y) can be written in the form:

$f=u^rg, \hspace{0.5em} \text{with} \hspace{0.5em} r \in \mathbb{Z} \hspace{0.5em} \text{and} \hspace{0.5em} g(P) \neq 0, \infty$

We define the order of $f$ at $P$ by:

# $ord_P(f)=r$

** DONE Example 11.1 (Washington)
Let $E: \hspace{0.5em} y^2 = X^3-x$.

We know that on E:

$\frac{x}{y}=\frac{y}{x^2-1}$

- What is the order of $f(x,y)=x$ in $P=(0,0)$ (a zero)?

$ord_{(0,0)}(x)=ord_{(0,0)}(y^2{\frac{1}{x^2-1}})=2$

Because $u(P) = y$ is $0$ at $P=(0,0)$, hence it is a uniformizer at $(0,0)$ and $g(x,y)=1/(x^2-1)$ is nonzero and finite at $(0,0)$.

- What is the order of $f(x,y)=\frac{x}{y}$ in $P=(0,0)$ (a zero)?

$ord_{(0,0)}(\frac{x}{y})=ord_{(0,0)}(y{\frac{1}{x^2-1}})=1$

again $y$ being the uniformizer.

** TODO Function divisors (principal divisors)
=Definition=

A *divisor of a function* $f$ on an elliptic curve $E$ is a formal sum of the points on the elliptic curve, weighted by the orders of the function $f$ at those points.
In more formal terms, if $P$ denotes a point(s) on $E$, the divisor associated with $f$ can be expressed as:

$\text{div} f = (f) = D_f = \sum_{P \in E} \text{ord}_P(f) \cdot P$

where:
- $\text{ord}_P(g)$ is the number of zeroes or poles at $P$ (it is negative if it represents the number of poles at $P$) .

A divisor is considered a *principal divisor* if it represents the zeroes and poles of some rational function (every rational function has as many zeroes as poles).

---

*NOTE*

Every divisor associated with a function $f$ is a principal divisor.
It characterizes the function's zeros and poles and reflects its algebraic properties on the curve.

---

** TODO Principal divisors: properties
- PairingsForBeginners p67

A divisor $D=\sum_{P}n_{P}P$ is *principal* (i.e. it is the divisor of a function) if and only if $\sum_{P}n_{P}=0$ and $\sum_{P}[n_{P}]P=\mathcal{O}$ on $E$.

For any $m\in\mathbb{Z}$ and $P\in E$ it follows that there exists a function $f_{m,P}$ with divisor:

$(f_{m,P})=m(P) - ([m]P)-(m-1)(\mathcal{O})$

Thus if $P\in E[r]$:, then $f_{r,P}$ has a divisor:

$(f_{r,P})=r(P)-r(\mathcal{O})$

Principal divisors are a device for keeping track of poles and zeroes.

For example, suppose a function $g$ has a zero of order 3 at a point $P$, and a pole of order 2 at another point $Q$ and a pole of order 1 at $\mathcal{O}$. (Note the number of zeroes and poles are equal, as they must be.)

Then using divisors, we can say all this concisely:

$\text{div}g=(g)=3(P)-2(Q)-(\mathcal{O})$

** TODO Example: Principal divisor (divisor of a function)

$E: \hspace{.5em} y^2 = (x - e_1) \times (x - e_2) \times (x - e_3)$

where:
- $P_i = (e_i,\mathcal{O})$

$\text{div}(x-e_1)=2\times P_{1} - 2 \times \mathcal{O}$

(see [[*Example: order of vanishing of a function at a point][Example: order of vanishing of a function at a point]] for details).

** TODO Example: Principal divisor
Consider a rational function defined on an elliptic curve:

$f(X, Y) = \frac{Y}{X - a}$

where $a$ is a constant.

- At a point where $Y = 0$ (e.g., a point on the x-axis), $f$ has a zero.
- At the point where $X = a$, $f$ has a simple pole.

The associated principal divisor $D_f$ can be expressed as:

$D_f = (P_1) - (P_2)$

where:
- $P_1$ is the point associated with the zero and
- $P_2$ with the pole of the function.

** Connection between point addition on an elliptic curve and divisors
- The *chord and tangent rule* for elliptic curves (see [[file:elliptic_curves.org::*EC group law][EC group law]]) states that given two points $P$ and $Q$ on the curve, the line (chord) connecting them intersects the curve at a third point, which can also be denoted as $R$.

- The process involves drawing a line that intersects the curve at three points: $P$, $Q$, and $R$, where $R$ is the point of addition $P + Q$. The coordinates of $R$ can be obtained through geometric operations defined on the elliptic curve.

- Each point addition can be associated with a divisor. For instance, when you compute $R = P + Q$, this addition can be represented as a divisor:
$D = P + Q - R$

** TODO Example: Finding a divisor of a function
** DONE Example 3.1.1 (PairingsForBeginners)
#+BEGIN_SRC sage :session . :exports both
F = FiniteField(103)
E = EllipticCurve(F, [20, 20])
P = E(26,20); Q = E(63,78); R = E(59,95); S = E(24,25); T = E(77,84); U = E(30,99)

E.is_on_curve(P[0], P[1]);

#D1 = E.divisor(P) + E.divisor(Q) - E.divisor(R) - E.divisor(S); D1
D1 = E.divisor([(1,P), (1,Q), (-1,R), (-1,S)]); D1
D1.support()
P + Q - R - S # !+ E(0,1,0) thus a function with (f) = (P) + (Q) - (R) - (S) does not exist (D1 is not a principal divisor)

D2 = E.divisor([(1,P), (1,Q), (-1,R), (-1,T)]); D2
P+Q-R-T # == E(0) thus there is some function f on E such that (f) = (P) + (Q) - (R) - (T)
#+END_SRC

#+RESULTS:
: True
: (x - 26*z, y - 20*z) + (x + 40*z, y + 25*z) - (x + 44*z, y + 8*z) - (x - 24*z, y - 25*z)
: [(26 : 20 : 1), (63 : 78 : 1), (59 : 95 : 1), (24 : 25 : 1)]
: (18 : 49 : 1)
: (x - 26*z, y - 20*z) + (x + 40*z, y + 25*z) - (x + 44*z, y + 8*z) - (x + 26*z, y + 19*z)
: (0 : 1 : 0)

** IN-PROGRESS Example 5.0.1 (PairingsForBeginners)
In this example given a divisor we find a corresponding rational function.

#+BEGIN_SRC sage :session . :exports both
q=23
Fq = FiniteField(q)
E = EllipticCurve(Fq, [17, 6])
E
E.order() # curve order is 30

# r =5 is the largest prime factor of the curves order
r = list(factor(E.order()))[2][0]
r

# point of order r=5
P=E(10,7)
5*P
# [r]P=0 therefore P is in E[r]
# thus (f_{5,P}) exists and has a divisor (f_5,P)=5(P)-5(O) (see 5.2)
#+END_SRC

#+RESULTS:
: Elliptic Curve defined by y^2 = x^3 + 17*x + 6 over Finite Field of size 23
: 30
: 5
: (0 : 1 : 0)

We will build $f_{5,P}$ using $f_{m+1,P}=f_{m,P} \cdot \frac{\ell_{[m]P,P}}{v_{[m+1]P}}$

---

*NOTE*

The divisor:

$(\frac{\ell_{[m]P,P}}{v[m+1],P})=(\ell_{[m]P,P}) - (v_{[m+1]P})=(P) + ([m]P) - ([m+1]P) - (\mathcal{O})$

---

*** =m = 1=

We compute the function:

$f_{1+1,P}=f_{1,P} \cdot \frac{\ell_{P,P}}{v[2]P}$

with divisor $(f_{2,P})=2(P)-([2]P)-(\mathcal{O})$.

Note that $(f_{1,P})$ is the zero divisor.
$\ell_{P,P}$ is the tangent line at $P=(10,7)$.
Let's find it's equation:

Diff both sides of E with respect to x:
# #+BEGIN_SRC maxima :exports both :results output replace
# y(x) := y^2;
# print(diff(y(x),x));
# #+END_SRC

$2y \frac{dy}{dx}=3x^2+17$

$\frac{dy}{dx}=\frac{3x^2+17}{2y}$

Evaluate at $P=(10,7)$ mod 23 to get the slope of the tangent line:

#+BEGIN_SRC sage :session . :exports both
q=23
F=GF(q)

F(F(3)*F(10)^2+F(17)) / F(F(2)*F(7))
#+END_SRC

#+RESULTS:
: 21

Using the point-slope form of the line $y-y_1=\lambda*(x-x_1)$ for $\lambda=21$ (slope), $x_1=10$, $y_1=7$ we get:

#+BEGIN_SRC sage :session . :exports both
q=23
Fq=GF(q)

# y = 21*x - 21*10 + 7
Fq(-21*10+7)
#+END_SRC

#+RESULTS:
: 4

Thus the tangent line at P is:

$\ell: y=21x+4$

Now to get the vertical line passing through $[2]P$:

---

*NOTE*

A vertical line on an elliptic curve is a line of the form:

$x=c$

where:
- $c$ is a constant.

This line passes through all points on the curve with x-coordinate equal to $c$.
For a given point $P=(x_1,y_1)$ the vertical line passing through P is simply:

$x=x_1$

---

#+BEGIN_SRC sage :session . :exports both
q=23
Fq=GF(q)

a=17; b=6;
E=EllipticCurve(Fq,[a,b]);

P=E(10,7)

S=2*P
S

Fq(S[0])
# this is the solution from the book:
Fq(-16)
#+END_SRC

#+RESULTS:
: (7 : 10 : 1)
: 7
: 7

Hence a vertical line passing through $[2]P$ is:

$v :x=7$

We can get the same results using closed-form formulas for the group law:

#+BEGIN_SRC sage :session . :exports both
q=23
Fq=GF(q)

a=17; b=6;
E=EllipticCurve(Fq,[a,b]);

Fxy.<x,y> = Fq[]; Fxy

def fDBL(P):
  lbda = (3*P[0]^2 + a) / (2*P[1]);
  c = P[1] - lbda*P[0];
  l = y - (lbda*x + c);
  v = x - (lbda^2 - 2*P[0]);
  return l/v;

P=E(10,7)

fDBL(P)
#+END_SRC

#+RESULTS:
: Multivariate Polynomial Ring in x, y over Finite Field of size 23
: (2*x + y - 4)/(x - 7)

This corresponds to the first solution (mod 23):

#+BEGIN_SRC sage :session . :exports both
q=23
Fq=GF(q)

a=17; b=6;
E=EllipticCurve(Fq,[a,b]);

Fxy.<x,y> = Fq[];

# manual solution
Fxy(y - 21*x - 4)
Fxy(x - 7)

# sage solution
Fxy(y + 2*x - 4)
Fxy(x - 7)

# solution from the book (MagmaScript)
Fxy(y + 2*x +19)
Fxy(x + 16)
#+END_SRC

#+RESULTS:
: 2*x + y - 4
: x - 7
: 2*x + y - 4
: x - 7
: 2*x + y - 4
: x - 7

Finally we get:

$f_{2,P}=\frac{y + 2*x - 4}{x - 7}$

*** =m = 2=
We compute the function:

$f_{3,P}=f_{2,P} \cdot \frac{\ell_{[2]P,P}}{v_{[3]P}}$

with the divisor:

$(f_{3,P})=3(P)-([3]P)-2(\mathcal{O})$,

where:
- $\ell_{[2]P,P}$ is the chord line through $P$ and $[2]P$ and $v_{[3]P}$ is the vertical line going through $[3]P$.

#+BEGIN_SRC sage :session . :exports both
q=23
Fq=GF(q)

a=17; b=6;
E=EllipticCurve(Fq,[a,b]);

Fxy.<x,y> = Fq[];

def fADD(P,Q):
  lbda = (Q[1] - P[1]) / (Q[0] - P[0]);
  c = P[1] - lbda * P[0];
  l = y - (lbda*x + c);
  v = x - (lbda^2 - P[0] - P[1]);
  return l/v;

P=E(10,7);

fADD(P,2*P)
#+END_SRC

#+RESULTS:
: (x + y + 6)/(x - 7)

Hence:

$f_{3,P}=\frac{y + 2*x - 4}{x - 7} \cdot \frac{x+y+6}{x-7}$

*** =m = 3=
We compute the function:

$f_{4,P}=f_{3,P} \cdot \frac{\ell_{[3]P,P}}{v_{[4]P}}$

with divisor $(f_{4,P})=4(P)-(4P)-3(\mathcal{O})$.

#+BEGIN_SRC sage :session . :exports both
q=23
Fq=GF(q)

a=17; b=6;
E=EllipticCurve(Fq,[a,b]);

Fxy.<x,y> = Fq[];

def fADD(P,Q):
  lbda = (Q[1] - P[1]) / (Q[0] - P[0]);
  c = P[1] - lbda * P[0];
  l = y - (lbda*x + c);
  v = x - (lbda^2 - P[0] - P[1]);
  return l/v;

P=E(10,7);

fADD(P,3*P)
#+END_SRC

#+RESULTS:
: (2*x + y - 4)/(x - 10)

*** =m = 4=
The last function we need has a divisor:

$(P)+(4P)-(5P)-(\mathcal{O})$

which would be the quotient of lines defining the group-law addition of $P$ and $4P$, but since $P$ has order 5: $P=-4P$

So this function actually has a divisor $(P)+(-P)-2(\mathcal{O})$ and the last update is simply the vertical line at $P$:

$v:x=10$

*** Combining the results:
#+BEGIN_SRC sage :session . :exports both
q=23
Fq=GF(q)

a=17; b=6;
E=EllipticCurve(Fq,[a,b]);

Fxy.<x,y> = Fq[];

def fDBL(P):
  lbda = (3*P[0]^2 + a) / (2*P[1]);
  c = P[1] - lbda*P[0];
  l = y - (lbda*x + c);
  v = x - (lbda^2 - 2*P[0]);
  return l/v;

def fADD(P,Q):
  lbda = (Q[1] - P[1]) / (Q[0] - P[0]);
  c = P[1] - lbda * P[0];
  l = y - (lbda*x + c);
  v = x - (lbda^2 - P[0] - P[1]);
  return l/v;

P=E(10,7);

f2P = fDBL(P)
f2P

f3P = f2P * fADD(P,2*P)
f3P

f4P = f3P * fADD(P,3*P)
f4P

f5P = f4P * Fxy(x-10)
f5P
#f5P.factor()

# WTF? not quite the same a the solution from the book which is:
(x+22)*y + 5*x^2 + 3*x + 5
#+END_SRC

#+RESULTS:
: (2*x + y - 4)/(x - 7)
: (2*x^2 + 3*x*y + y^2 + 8*x + 2*y - 1)/(x^2 + 9*x + 3)
: (4*x^3 + 8*x^2*y + 5*x*y^2 + y^3 + 8*x^2 - 2*y^2 - 11*x - 9*y + 4)/(x^3 - x^2 + 5*x - 7)
: (4*x^3 + 8*x^2*y + 5*x*y^2 + y^3 + 8*x^2 - 2*y^2 - 11*x - 9*y + 4)/(x^2 + 9*x + 3)
: 5*x^2 + x*y + 3*x - y + 5

* IN-PROGRESS The Weil Pairing

=Definition=

Let $P,Q \in E(F_{q^k})[r]$ and let $D_P$ and $D_q$ be degree zero divisors with disjoint supports, such that $D_P \sim (P)-(\mathcal{O})$ and $D_Q \sim (Q)-(\mathcal{O})$. There exist functions $f$ and $g$ such that $(f)=rD_P$ and $(g)=rD_Q$. 

The *Weil pairing* $w_r$ is a map:

$w_r: E(F_{q^k})[r] \times E(F_{q^k})[r] \rightarrow \mu_r$

defined as:

$w_r(P,Q)=\frac{f(D_Q)}{g(D_P)}$

where:
- $\mu_r$ is the group of $r-th$ roots of unity in the multiplicative group $F_{q^k}^{*}$.

---

*NOTE*

- Note how in the definition both points P and Q come from the full r-torsion as defined on the curve's extension.
- For a point $P \in E[r]$ the function $f_{r,P}$ with divisor $r(P)-r(\mathcal{O})$ is at the heart of both the Weil and Tate pairing definitions.

---

** IN-PROGRESS Example 5.1.1: constructing the Weil pairing
*** DONE $E/F_{23}: y^2=x^3-x$

Note that the curve is supersingular.

---

*NOTES*

- Supersingular curve E defined over field F with characteristic p has no (non-trivial) *p-torsion points*
- it's *Hasse invariant = 0* (coefficient of $x^{p-1}$ in  $f^{(p-1)/2}$, where  $y^2 = f(x)$) vanishes.

---

#+BEGIN_SRC sage :session . :exports both
q=23
Fq=GF(q)
E=EllipticCurve(Fq, [-1,0])
E
# E is supersingular
E.order() == q+1

print(f"E is supersingular: {E.is_supersingular()}")

# no q-torsion points:
q_torsion=[P for P in E.points() if q * P == E(0)]
# contain only the point at infinity:
q_torsion

# Define f(x) = x^3 - x
f = x^3 - x
f

power = f^((q-1)//2)
hasse_invariant = power.coefficient(x^(q-1))

print(f"Hasse invariant for E: {hasse_invariant}")
#+END_SRC

#+RESULTS:
: Elliptic Curve defined by y^2 = x^3 + 22*x over Finite Field of size 23
: True
: E is supersingular: True
: [(0 : 1 : 0)]
: x^3 - x
: Hasse invariant for E: 0

*** DONE Point $P$ of order $r$, subgroup $<P>$ and pairing subgroup $\mathbb{G}_1[r]$.

---

*NOTE*

By $<P>$ we understand the subgroup generated by the point $P$ (see [[file:elliptic_curves.org::*Subgroup $<P>$ Generated by a Point P][Subgroup $<P>$ Generated by a Point P]]).
In this example it is equivalent to the $\mathbb{G}_1[r]$ (pairing) subgroup of the full r-torsion (the $E(F_{q^k(r)})[r]$ r-torsion for r=3, where r is the order of the point P, defined on the extended curve.).

---

#+BEGIN_SRC sage :session . :exports both
q=23
Fq=GF(q)
E=EllipticCurve(Fq, [-1,0])

P=E(2,11)

P_order = [r for r in range(1,q+1) if r*P == E(0)][0]

print(f"Order of {P} is {P_order}")
P.order()

# subgroup <P> generated by P
P_gen_subgroup=[r*P for r in range(1,P.order()+1)]

print(f"Subgroup generated by P: {P_gen_subgroup}")

# this is the same subgroup as G1
r=P.order()
G1=[P for P in E.points() if r*P == E(0) ]
G1

# P is the element of G1
P in G1

# frobenius endomorphism acts trivially on points from G1:
def pi(P,E,q):
  if P == E(0): return E(0)
  x, y = P.xy()
  return E([x^q, y^q])

P == pi(P,E,q)
#+END_SRC

#+RESULTS:
: Order of (2 : 11 : 1) is 3
: 3
: Subgroup generated by P: [(2 : 11 : 1), (2 : 12 : 1), (0 : 1 : 0)]
: [(0 : 1 : 0), (2 : 11 : 1), (2 : 12 : 1)]
: True
: True

*** DONE Embedding degree $k(r)$, field extension $F_{q^{k(r)}}$ and the extended elliptic curve

#+BEGIN_SRC sage :session . :exports both
q=23
Fq=GF(q)
E=EllipticCurve(Fq, [-1,0])

P=E(2,11)

r=P.order()
k=r-1

print(f"Embedding degree with respect to P's order: r={r}")
# extending F to Fq^k(r):
Fq2.<i> = GF(q^2, modulus=x^2 + 1)
Fq2

E2=EllipticCurve(Fq2, [-1,0])
E2
#+END_SRC

#+RESULTS:
: Embedding degree with respect to P's order: r=3
: Finite Field in i of size 23^2
: Elliptic Curve defined by y^2 = x^3 + 22*x over Finite Field in i of size 23^2

*** DONE Point $Q \in E/F_{q^k(r)}$ and the trace zero subgroup $\mathbb{G_{2}}$

---

*NOTE*

The *trace zero subgroup* of an elliptic curve $E$ defined over a finite field $\mathbb{F}_q$ is a subgroup that arise when considering the curve over an extension field $\mathbb{F}_{q^n}$:

=Definition=

The *trace zero subgroup* (also called the $\Gamma$ -subgroup$) over the degree $n$ extension $\mathbb{F}_{q^n}$ consists of points $P \in E(\mathbb{F}_{q^n})$  whose *Frobenius trace* vanishes:

$\Gamma_n(E) = \left\{ P \in E(\mathbb{F}_{q^n}) \mid \text{Tr}(P) = P + \pi(P) + \pi^2(P) + \dots + \pi^{n-1}(P) = \mathcal{O} \right\}$

where:
- $\pi$ is the *Frobenius endomorphism* $\pi(x, y) = (x^q, y^q)$.

---

#+BEGIN_SRC sage :session . :exports both
q=23
Fq=GF(q)
E=EllipticCurve(Fq, [-1,0])
k=2
Fq2.<i> = GF(q^k, modulus=x^2 + 1)
E2=EllipticCurve(Fq2, [-1,0])

# this is the "full" r-torsion (the 3-torsion on the curve extended to the embedding degree k(r)=2, for r=3):
full_r_torsion = [Q for Q in E2.points() if 3*Q == E2(0)]
#full_r_torsion

# Frobenius endomorphism (Frobenius map)
def pi(P,E,q):
  if P == E(0): return E(0)
  x, y = P.xy()
  return E([x^q, y^q])

# frobenius trace
def Tr(P,E,q,k):
        return sum(pi(P,E,q^i) for i in range(k))

# should be the same as (since k=2)
Tr(Q,E2,q,k) == Q+pi(Q,E2,q)

# G2 consists of these elements of the full r-torsion E/F_q^{k(r)}[r] for which the Frobenius trace vanishes (by the equivalent definition)
trace_zero_subgroup = [P for P in full_r_torsion if Tr(P,E2,q,k) == E2(0)]

# By the G2 definition Q is in the trace zero subgroup since:
q*Q == pi(Q, E2, q)

G2=trace_zero_subgroup

print(f"Trace zero subgroup G2={G2}")

# Q is the element of G2
print(f"Q={Q} is in the G2: {Q in G2}")

# but not of G1 defined earlier
print(f"Q={Q} is in the G1: {Q in G1}")
#+END_SRC

#+RESULTS:
: True
: True
: Trace zero subgroup G2=[(0 : 1 : 0), (21 : 11*i : 1), (21 : 12*i : 1)]
: Q=(21 : 12*i : 1) is in the G2: True
: Q=(21 : 12*i : 1) is in the G1: False

*** DONE Finding $f_{3,P}$ and $g_{3,Q}$

---

*NOTE*

The Miller function $f_{m,P}$ is defined to have a divisor:

$(f_{m,P}) = m(P) - m(\mathcal{O}) - (mP) + (\mathcal{O})$

For $m = 1$, this simplifies to:

$(f_{1,P}) = 1(P) - 1(\mathcal{O}) - (1P) + (\mathcal{O}) = (P) - (\mathcal{O}) - (P) + (\mathcal{O}) = 0$

This would break the recursion in the Miller's algorithm.
By convention, we therefore choose:

$f_{1,P} = 1$

---

Given a divisor $(f_{r,P})=r(P)-r(\mathcal{O})$ (for $r=3$) we will find a corresponding rational function.

We will build $f_{3,P}$ using $f_{m+1,P}=f_{m,P} \cdot \frac{\ell_{[m]P,P}}{v_{[m+1]P}}$

where:
- $\ell_{P_1,P_2}$ is the line passing through $P_1$ and $P_2$ (chord line)
  - $\ell_{P,P}$ is the tangent line
- $v_P$ is the vertical line passing through P

We will do the same for $g_{3,Q}=3(Q)-3 \mathcal{O}$

#+BEGIN_SRC sage :session . :exports both
q=23
Fq=GF(q)
a=-1
b=0
E=EllipticCurve(Fq, [a,b])
k=2
Fq2.<i> = GF(q^k, modulus=x^2 + 1)
E2=EllipticCurve(Fq2, [a,b])

P=E2(2,11)
Q=E2(21,12*i)

Fxy.<x,y> = Fq[];

def fDBL(P):
  lbda = (3*P[0]^2 + a) / (2*P[1]);
  c = P[1] - lbda*P[0];
  l = y - (lbda*x + c);
  v = x - (lbda^2 - 2*P[0]);
  return l/v;

def fADD(P1,P2):
  lbda = (P2[1] - P1[1]) / (P2[0] - P1[0]);
  c = P[1] - lbda * P1[0];
  l = y - (lbda*x + c);
  v = x - (lbda^2 - P1[0] - P1[1]);
  return l/v;

f1P=1
f2P=f1P * fDBL(P)
#f2P
# normally fADD(P,2*P) but since 3P=0 this is just the vertical line through P
f3P=f2P*(x-P[0])

print(f"Rational function f_3P = {f3P}")

# same for Q (Q is of order 3)
g3Q=fDBL(Q)*(x-Q[0])
print(f"Rational function g_3Q = {g3Q}")

# verify with a built-in function:
E2.divisor([(3,P), (3,E(0))])
E2.divisor([(3,Q), (3,E2(0))])

#+END_SRC

#+RESULTS:
: Rational function f_3P = 11*x + y - 10
: Rational function g_3Q = (11*i)*x + y + (10*i)
: 3*(x - 2*z, y - 11*z) + 3*(x, z)
: 3*(x + 2*z, y + (11*i)*z) + 3*(x, z)
*** DONE Finding $f$ with a divisor $D_P$ and $g$ with a divisor $D_Q$

We have found a function $f_{r,P}$ with a divisor:

$(f_{r,P})=r(P)-r(\mathcal{O}$).

We need to find a function $f$ with a divisor $D_P$ such that:

$(f)=D_P \sim (P)-(\mathcal{O})$

(same for function $g$ with a divisor $D_Q$, noting that $D_P$ and $D_Q$ need to have distinct supports by the definition of the Weil pairing).

#+BEGIN_SRC sage :session . :exports both
q=23
Fq=GF(q)
a=-1
b=0
k=2
Fq2.<i> = GF(q^k, modulus=x^2 + 1)
E2=EllipticCurve(Fq2, [a,b])

P=E2(2,11)
Q=E2(21,12*i)

Df3P=E2.divisor([(3,P), (3,E(0))])
Dg3Q=E2.divisor([(3,Q), (3,E2(0))])

# supports of (f_r,P) and (f_r,Q) are not distinct
print(f"3(P)-3(0) support: {Df3P.support()}")
print(f"3(Q)-3(0) support: {Dg3Q.support()}")

#+END_SRC

#+RESULTS:
: 3(P)-3(0) support: [(2 : 11 : 1), (0 : 1 : 0)]
: 3(Q)-3(0) support: [(21 : 12*i : 1), (0 : 1 : 0)]

---

*NOTE*

Technically only one of the divisors needs updating, so that it's support does not include $\mathcal{O}$ but for illustrative purposes both are updated.

---

We take two random points on $E(F_q^k)$: $R$ and $S$ and we set:

$D_P=(P+R)-(R)$
$D_P=(P+R)-(R)$

We find $f$ with a divisor $D_P$ as :

$f = \frac{f_{r,P}}{(\ell{P,R} / v_{P+R})&^3}$

We find $g$ with a divisor $D_Q$ as :

$g = \frac{_{r,Q}}{(\ell{Q,S} / v_{Q+S})&^3}$

where:
- $\ell_{P_1,P_2}$ is the line passing through $P_1$ and $P_2$ (chord line)
  - $\ell_{P,P}$ is the tangent line
- $v_P$ is the vertical line passing through P

#+BEGIN_SRC sage :session . :exports both
q=23
Fq=GF(q)
a=-1
b=0
k=2
Fq2.<i> = GF(q^k, modulus=x^2 + 1)
E2=EllipticCurve(Fq2, [a,b])

Fxy.<x,y> = Fq[];

def fDBL(P):
  lbda = (3*P[0]^2 + a) / (2*P[1]);
  c = P[1] - lbda*P[0];
  l = y - (lbda*x + c);
  v = x - (lbda^2 - 2*P[0]);
  return l/v;

def fADD(P1,P2):
  lbda = (P2[1] - P1[1]) / (P2[0] - P1[0]);
  c = P[1] - lbda * P1[0];
  l = y - (lbda*x + c);
  v = x - (lbda^2 - P1[0] - P1[1]);
  return l/v;

R=E2(17*i, 2*i + 21)
S=E2(10*i + 18, 13*i + 13)

f3P=fDBL(P)*(x-P[0])
g3Q=fDBL(Q)*(x-Q[0])


lPR=fADD(P,R);
lQS=fADD(Q,S);

# same as f3P,R
f=f3P/lPR^3;
f

# same as f3Q,S
g=g3Q/lQS^3;
g
#+END_SRC

#+RESULTS:

*** IN-PROGRESS The Weil pairing for P and Q

We can now compute the Weil pairing according to the definition as:

$w_r(P,Q) = \frac{f(D_Q)}{g(D_P)} = \frac{f(Q+S) \cdot g(R)} {f(S) \cdot g(P+R)}$

#+BEGIN_SRC sage :session . :exports both
q=23
Fq=GF(q)
a=-1
b=0
k=2
Fq2.<i> = GF(q^k, modulus=x^2 + 1)
E2=EllipticCurve(Fq2, [a,b])

Fxy.<x,y> = Fq[];

P=E2(2,11)
Q=E2(21,12*i)

def fDBL(P):
  lbda = (3*P[0]^2 + a) / (2*P[1]);
  c = P[1] - lbda*P[0];
  l = y - (lbda*x + c);
  v = x - (lbda^2 - 2*P[0]);
  return l/v;

def fADD(P1,P2):
  lbda = (P2[1] - P1[1]) / (P2[0] - P1[0]);
  c = P[1] - lbda * P1[0];
  l = y - (lbda*x + c);
  v = x - (lbda^2 - P1[0] - P1[1]);
  return l/v;

f3P=fDBL(P)*(x-P[0])
g3Q=fDBL(Q)*(x-Q[0])

R=E2(17*i, 2*i + 21)
S=E2(10*i + 18, 13*i + 13)

lPR=fADD(P,R)
lQS=fADD(Q,S)

# same as f3P,R
f=f3P/lPR^3
# same as g3
g=g3Q/lQS^3

# TODO: not the same, why?
eWr=f((Q+S).xy()) * g(R.xy()) / (f(S.xy())*g((P+R).xy()))

print(f"The Weil pairing for P={P} and Q={Q}: {eWr}")

# verify with a built-in function:
e=P.weil_pairing(Q, 3)
e

# Pairing value is in the \mu_3
e^3

#+END_SRC

#+RESULTS:
: The Weil pairing for P=(2 : 11 : 1) and Q=(21 : 12*i : 1): 15*i + 22
: 15*i + 11
: 1

*** DONE Bilinearity of the pairing

We will demonstrate that the computed Weil paitring is indeed a [[*Billinear map][billinear map]].

#+BEGIN_SRC sage :session . :exports both
q=23
a=-1
b=0
k=2
Fq2.<i> = GF(q^k, modulus=x^2 + 1)
E2=EllipticCurve(Fq2, [a,b])

P=E2(2,11)
Q=E2(21,12*i)

# e(P+P,Q) = e(P,Q) * e(P,Q)
(P+P).weil_pairing(Q, 3) == P.weil_pairing(Q,3)^2

# e(P,Q+Q) = e(P,Q) * e(P,Q)
P.weil_pairing(Q+Q, 3) == P.weil_pairing(Q,3)^2

# e(P+P,Q+Q) = e(P,Q) * e(P,Q) * e(P,Q) * e(P,Q)
(P+P).weil_pairing(Q+Q, 3) == P.weil_pairing(Q,3)^4
#+END_SRC

#+RESULTS:
: True
: True
: True

* Teaser: pairings in ZK
** Example 1

=both parties=

There exists a (symmetric, i.e. $G_0=G_1$) pairing $e: G_0 \times G_1 \rightarrow G_T$
and a $G$ which is a generator of $G_0=G_1$

=prover=

I know $a=200$ and $b=275$ such that
$200G=A, \quad 275G=B \quad \text{and} \quad (200 \times 275)G=D$

=verifier=

Receives $A,B$ and $D$ and wants to check whether $D$ was computed correctly.
He can do so without knowing the secrets $a=200$ and $b=275$ by using pairings and checking if:
$e(A,B)=e(G,D)$

which in this case holds:
$e(A,B)=e(200G,275G)=e\left(G,(200 \times 275) G \right)=e(G,D)$
** Example 2
If a statement can be transformed into a relationship with a single multiplication than it can easily be checked using a pairing.

=prover=

*statement*:
I know an $a$ which is a solution to:
$x^2+2027x+16152$

---
*NOTE*

#+BEGIN_SRC sage :session . :exports both
x = var('x')
solve(x^2+2027*x+16152, x)
#+END_SRC

#+RESULTS:
: [x == -2019, x == -8]

---

Prover takes a pair of two elliptic curve points $g_1$ and $g_2$ and computes $a \times g_1$ and $a \times g_2$.
He sends the results along with the points $g_1$ and $g_2$ to the verifier.
Because of the ECDLP he can be sure verifier cannot compute $a$ knowing $a \times g_1$ and $a \times g_2$.

=verifier=

Verifier recieves $g_1$, $g_2$, $a \times g_1$ and $a \times g_2$.
He then computes:

\begin{equation*}
e\left(ag_1, ag_2 \right) \times e\left(g_1, -2027ag_2 \right) \times e\left(g_1, 16152g_2 \right)
\end{equation*}

which by the billinearity property of the map $e$ is the same as computing:

\begin{equation*}
e\left(g_1,g_2\right)^{a^2+2027a+16152}
\end{equation*}

and if the result is $1$ then $a^2+2027a+16152$ is equal to $0$ (with high probability), QED.

---

*NOTE*

In a zk-SNARK, elliptic curve pairings are used to check a system of quadratic constraints just like this one.
The system of constraints is converted into a single, large polynomial that has particular roots if and only if each of the (quadratic) constraints is satisfied.

---

* Additional materials
- Divisor [0/2]
  - [ ] https://crypto.stanford.edu/pbc/notes/elliptic/divisor.html
  - [-] https://alozano.clas.uconn.edu/math5020-elliptic-curves/
    - [X] 5a order of vanishing: https://youtu.be/Oh_4u-xSCro?t=234
    - [X] 5b order of vanishing examples: https://www.youtube.com/watch?v=2t13YpFZwn8
    - [ ] order of vanishing: derivation by taylor expansion (in the projective coordinates): https://youtu.be/2t13YpFZwn8?t=884
    - [ ] divisors: https://www.youtube.com/watch?v=-UoizKdoHOU
