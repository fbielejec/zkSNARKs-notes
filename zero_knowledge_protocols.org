#+STARTUP: overview
#+latex_class_options: [14pt]

* IN-PROGRESS Statements
- In the formal language context *statements* provide membership claims.
 - *instances* are constructive proofs of the statements.
** DONE Formal Languages

=General definition: Language=

Let $\Sigma$ be any set. Let $\Sigma^{*}$ be the set of all strings of a finite length $<x_1, \ldots,x_n>$ of elements $x_j \in \Sigma$, including the empty string $<> \in \Sigma^{*}$.
The *language* $L$ is a subset of the set of all finite strings $\Sigma^{*}$.
In this context:
- The set $\Sigma$ is called the *alphabet* of the language *L*.
- Elements from $\Sigma$ are called letters.
- Elements from $L$ are called *words*.
- If there are rules that specify which strings from $\Sigma^{*}$ belong to the language, these rules are called the *grammar* of the language.

** DONE Decision functions

*Decison function* $R$:

$R: \hspace{.5em} \Sigma^{*} \rightarrow \{ true, false \}$

decides whether a given string $x \in \Sigma^{*}$ is an element of the language or not.
The associated language can be written as the set off all strings decided by $R$:

$L_R:=\{ x \in \Sigma^{*} \hspace{.5em} | \hspace{.5em} R(x) = true \}$

=Definiton: statement=

*Statement* $S$ is the claim that language $L$ contains a word $x$.
A *proof* for statement $S$ is given by some string $P \in \Sigma^{*}$.
Such proof is *verified* by checking if:

$R(P)=true$

In this case $P$ is called an *instance* of the statement $S$.
** DONE Example: The empty language (Example 114 MoonMath)
Consider the alphabet $\Sigma=\mathbb{Z}_6$ , where $\mathbb{Z}_6$ is the ring of modular 6 arithmetic as derived in [[file:arithmetics.org::*Example 11 MoonMath (Arithmetic modulo $6$)][Arithmetic modulo $6$]].

- *Alphabet*: $\Sigma = \mathbb{Z}_6 = \{ 0, 1, 2, 3, 4, 5 \}$.
- *Language*: $L = \{ x \in (\mathbb{Z}_6)^* \mid x \times x \equiv 2 \pmod{6} \}$
  - where $x$ is a single element in $\mathbb{Z}_6$
- *Decision Function*:
$R(x) =  \begin{cases}
\text{True} & \text{if } x \times x \equiv 2 \pmod{6}, \\
\text{False} & \text{otherwise.}
\end{cases}$

Since $0^=0, 1^2=1, 2^2=4, 3^2=3, 4^2=4, 5^2=1$ no element has it's square equa to 2 (mod 6), the language is empty.

#+BEGIN_SRC sage :session . :exports both
Z6 = Integers(6)

def R(x):
    """
    Decision function for whether x * x \\equiv 2 mod 6.
    """
    return Z6(x)^2 == Z6(2)

for x in range(6):
    print(f"R({x}) = {R(x)}")
#+END_SRC

#+RESULTS:
: R(0) = False
: R(1) = False
: R(2) = False
: R(3) = False
: R(4) = False
: R(5) = False

** DONE Example: 3-Factorization (Example 115 MoonMath)
/Language which consists of those elements of the field $F_13$ that can be factored into 3 other elements./

Formalizing the description:
- *Alphabet*: $\Sigma = F_{13}$.
- *Language*: $L_{3,fac} = \{ x_1, x_2, x_3, x_4 \in F_{13}: \hspace{.5em} x_4 = x_1 \cdot x_2 \cdot x_3 \}$.
- *Decision Function*:
$R(<x_1,x_2,x_3,x_4>) =  \begin{cases}
\text{True} & \text{if } x_4 = x_1 \cdot x_2 \cdot x_3 \\
\text{False} & \text{otherwise.}
\end{cases}$,

where:
- $x_1, x_2, x_3, x_4 \in F_{13}$

The string $<2, 12, 4, 5>$ is a constructive proof for the statement that L_{13,fac} contains words:

#+BEGIN_SRC sage :session . :exports both
F13 = GF(13)

def R(x1,x2,x3,x4):
    return F13(x4) == F13(x1)*F13(x2)*F13(x3)

x1=2; x2=12; x3=4; x4=5

# verification of the proof
print(f"R{x1,x2,x3,x4} = {R(x1,x2,x3,x4)}")
#+END_SRC

#+RESULTS:
: R(2, 12, 4, 5) = True
** DONE Example: Tiny-jubjub Membership (Example 116 MoonMath)
/Language where word are points on the Tiny-jubjub curve (in it's Twisted Edwards form)./

Formalizing the description:
- *Alphabet*: $\Sigma = F_{13}$.
- *Decision Function*:
$R(x_1,x_2) =  \begin{cases}
\text{True} & \text{if } 3 \cdot x_{1}^{2} + x_{2}^{2} = 1 + 8 \cdot x_{1}^{2} \cdot x_{2}^{2} \\
\text{False} & \text{otherwise.}
\end{cases}$
- *Language*:
$L = \{ x_1, x_2 \in F_{13} : \hspace{.5em} R(x_1,x_2) = true \}$

Any of the points on the curve is therefore a constructive proof that the there is a word in the language:

#+BEGIN_SRC sage :session . :exports both
F13 = GF(13)

L_ETJJ = []
for x in F13:
  for y in F13:
    if F13(3)*x^2 + y^2 == 1+ F13(8)*x^2*y^2:
      L_ETJJ.append((x,y))

ETJJ = Set(L_ETJJ)
ETJJ
#+END_SRC

#+RESULTS:
: {(0, 1), (8, 8), (11, 7), (1, 2), (2, 7), (1, 11), (6, 4), (7, 9), (10, 0), (12, 2), (12, 11), (7, 4), (5, 5), (5, 8), (3, 0), (11, 6), (0, 12), (2, 6), (6, 9), (8, 5)}

** IN-PROGRESS Instance and witness
- in the context of a zero-knowledge proof system it is possible to hide parts of the proof instance and still be able to prove the statement.
- the proof is split into a public part called the *instance* and a private part called the *witness*.

=Definition: decision function with an instance and a witness=

$R: \hspace{.5em} \Sigma_{I}^{*} \times \Sigma_{W}^{*} \rightarrow \{\text{true, false} \}; \hspace{.5em} (i,w) \mapsto R(i,w)$

where:
- words are strings $(i,w)\in \Sigma_I^{*} \times \Sigma_W^{*}$ for which $R(i,w)=true$.
- the input $i \in \Sigma_{I}$ is called an instance.
- the input $w \in \Sigma_{W}$ is called a witness.

=Definition: language with an instance and a witness=

$L_R := \{ (i,w) \in \Sigma_{I}^{*} \times \Sigma_{W}^{*} \hspace{.5em} | \hspace{.5em} R(i,w) = true \}$

In this context *statement* $S$ is a claim that given an instance $i$ there is a witness $w$ such that the language $L$ contains a word $(i,w)$.
A constructive proof for $S$ is a string $P=(i,w)$ and it is verified by $R(P)=true$.
*** IN-PROGRESS Example: SHA256 - Knowledge of Preimage (Example 117 MoonMath)
/Given a digest $i$ there is a preimage $w$ such that SHA256(w)=i$/

SHA256 maps arbitary length binary strings to binary strings of length 256:

$\text{SHA256}: \hspace{.5em} | \hspace{.5em} \{0,1\}^{*} \rightarrow \{0,1\}^{256}$

Formal description of the language:

- *Alphabet*: 
  - for the set of all instances: $\Sigma_I = \{0,1\}$
  - for the set of all witnesses: $\Sigma_W = \{0,1\}$
- *Decision function:*
$R_{SHA256}: \hspace{.5em} | \hspace{.5em} \{0,1\}^{*} times \{0,1\}^{*} \rightarrow \{true,false\};$ s.t.
$(i;w) \mapsto \begin{cases}
\text{True} & |i|=256, i=SHA256(w) \\
\text{False} & \text{otherwise.}
\end{cases}$

* TODO Groth16
* TODO PLONK
