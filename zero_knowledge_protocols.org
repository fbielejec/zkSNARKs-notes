#+STARTUP: overview
#+latex_class_options: [14pt]

* DONE Statements
- In the formal language context *statements* provide membership claims.
 - *instances* are constructive proofs of the statements.
** DONE Formal Languages

=General definition: Language=

Let $\Sigma$ be any set. Let $\Sigma^{*}$ be the set of all strings of a finite length $<x_1, \ldots,x_n>$ of elements $x_j \in \Sigma$, including the empty string $<> \in \Sigma^{*}$.
The *language* $L$ is a subset of the set of all finite strings $\Sigma^{*}$.
In this context:
- The set $\Sigma$ is called the *alphabet* of the language *L*.
- Elements from $\Sigma$ are called letters.
- Elements from $L$ are called *words*.
- If there are rules that specify which strings from $\Sigma^{*}$ belong to the language, these rules are called the *grammar* of the language.

** DONE Decision functions

*Decison function* $R$:

$R: \hspace{.5em} \Sigma^{*} \rightarrow \{ true, false \}$

decides whether a given string $x \in \Sigma^{*}$ is an element of the language or not.
The associated language can be written as the set off all strings decided by $R$:

$L_R:=\{ x \in \Sigma^{*} \hspace{.5em} | \hspace{.5em} R(x) = true \}$

=Definiton: statement=

*Statement* $S$ is the claim that language $L$ contains a word $x$.
A *proof* for statement $S$ is given by some string $P \in \Sigma^{*}$.
Such proof is *verified* by checking if:

$R(P)=true$

In this case $P$ is called an *instance* of the statement $S$.
*** DONE Example: The empty language (Example 114 MoonMath)
Consider the alphabet $\Sigma=\mathbb{Z}_6$ , where $\mathbb{Z}_6$ is the ring of modular 6 arithmetic as derived in [[file:arithmetics.org::*Example 11 MoonMath (Arithmetic modulo $6$)][Arithmetic modulo $6$]].

- *Alphabet*: $\Sigma = \mathbb{Z}_6 = \{ 0, 1, 2, 3, 4, 5 \}$.
- *Language*: $L = \{ x \in (\mathbb{Z}_6)^* \mid x \times x \equiv 2 \pmod{6} \}$
  - where $x$ is a single element in $\mathbb{Z}_6$
- *Decision Function*:
$R(x) =  \begin{cases}
\text{True} & \text{if } x \times x \equiv 2 \pmod{6}, \\
\text{False} & \text{otherwise.}
\end{cases}$

Since $0^=0, 1^2=1, 2^2=4, 3^2=3, 4^2=4, 5^2=1$ no element has it's square equa to 2 (mod 6), the language is empty.

#+BEGIN_SRC sage :session . :exports both
Z6 = Integers(6)

def R(x):
    """
    Decision function for whether x * x \\equiv 2 mod 6.
    """
    return Z6(x)^2 == Z6(2)

for x in range(6):
    print(f"R({x}) = {R(x)}")
#+END_SRC

#+RESULTS:
: R(0) = False
: R(1) = False
: R(2) = False
: R(3) = False
: R(4) = False
: R(5) = False

*** DONE Example: 3-Factorization (Example 115 MoonMath)
/Language which consists of those elements of the field $F_13$ that can be factored into 3 other elements./

Formalizing the description:
- *Alphabet*: $\Sigma = F_{13}$.
- *Language*: $L_{3,fac} = \{ x_1, x_2, x_3, x_4 \in F_{13}: \hspace{.5em} x_4 = x_1 \cdot x_2 \cdot x_3 \}$.
- *Decision Function*:
$R(<x_1,x_2,x_3,x_4>) =  \begin{cases}
\text{True} & \text{if } x_4 = x_1 \cdot x_2 \cdot x_3 \\
\text{False} & \text{otherwise.}
\end{cases}$,

where:
- $x_1, x_2, x_3, x_4 \in F_{13}$

The string $<2, 12, 4, 5>$ is a constructive proof for the statement that L_{13,fac} contains words:

#+BEGIN_SRC sage :session . :exports both
F13 = GF(13)

def R(x1,x2,x3,x4):
    return F13(x4) == F13(x1)*F13(x2)*F13(x3)

x1=2; x2=12; x3=4; x4=5

# verification of the proof
print(f"R{x1,x2,x3,x4} = {R(x1,x2,x3,x4)}")
#+END_SRC

#+RESULTS:
: R(2, 12, 4, 5) = True
*** DONE Example: Tiny-jubjub Membership (Example 116 MoonMath)
/Language where word are points on the Tiny-jubjub curve (in it's Twisted Edwards form)./

Formalizing the description:
- *Alphabet*: $\Sigma = F_{13}$.
- *Decision Function*:
$R(x_1,x_2) =  \begin{cases}
\text{True} & \text{if } 3 \cdot x_{1}^{2} + x_{2}^{2} = 1 + 8 \cdot x_{1}^{2} \cdot x_{2}^{2} \\
\text{False} & \text{otherwise.}
\end{cases}$
- *Language*:
$L = \{ x_1, x_2 \in F_{13} : \hspace{.5em} R(x_1,x_2) = true \}$

Any of the points on the curve is therefore a constructive proof that the there is a word in the language:

#+BEGIN_SRC sage :session . :exports both
F13 = GF(13)

L_ETJJ = []
for x in F13:
  for y in F13:
    if F13(3)*x^2 + y^2 == 1+ F13(8)*x^2*y^2:
      L_ETJJ.append((x,y))

ETJJ = Set(L_ETJJ)
ETJJ
#+END_SRC

#+RESULTS:
: {(0, 1), (8, 8), (11, 7), (1, 2), (2, 7), (1, 11), (6, 4), (7, 9), (10, 0), (12, 2), (12, 11), (7, 4), (5, 5), (5, 8), (3, 0), (11, 6), (0, 12), (2, 6), (6, 9), (8, 5)}

* DONE Instance and witness
- in the context of a zero-knowledge proof system it is possible to hide parts of the proof instance and still be able to prove the statement.
- the proof is split into a public part called the *instance* and a private part called the *witness*.

=Definition: decision function with an instance and a witness=

$R: \hspace{.5em} \Sigma_{I}^{*} \times \Sigma_{W}^{*} \rightarrow \{\text{true, false} \}; \hspace{.5em} (i,w) \mapsto R(i,w)$

where:
- words are strings $(i,w)\in \Sigma_I^{*} \times \Sigma_W^{*}$ for which $R(i,w)=true$.
- the input $i \in \Sigma_{I}$ is called an instance.
- the input $w \in \Sigma_{W}$ is called a witness.

=Definition: language with an instance and a witness=

$L_R := \{ (i,w) \in \Sigma_{I}^{*} \times \Sigma_{W}^{*} \hspace{.5em} | \hspace{.5em} R(i,w) = true \}$

In this context *statement* $S$ is a claim that given an instance $i$ there is a witness $w$ such that the language $L$ contains a word $(i,w)$.
A constructive proof for $S$ is a string $P=(i,w)$ and it is verified by $R(P)=true$.
*** DONE Example: SHA256 - Knowledge of Preimage (Example 117 MoonMath)
/Given a digest $i$ there is a preimage $w$ such that SHA256(w)=i$/

SHA256 maps arbitary length binary strings to binary strings of length 256:

$\text{SHA256}: \hspace{.5em} | \hspace{.5em} \{0,1\}^{*} \rightarrow \{0,1\}^{256}$

Formal description of the language:

- *Alphabet*:
  - for the set of all instances: $\Sigma_I = \{0,1\}$
  - for the set of all witnesses: $\Sigma_W = \{0,1\}$
- *Decision function:*
$R_{SHA256}: \hspace{.5em} | \hspace{.5em} \{0,1\}^{*} \times \{0,1\}^{*} \rightarrow \{true,false\};$ s.t.
$(i;w) \mapsto \begin{cases}
\text{True} & |i|=256, i=SHA256(w) \\
\text{False} & \text{otherwise.}
\end{cases}$
- *Language*:
$L_{SHA256} := \{ (i;w) \in \{0,1\}^{*} \times \{0,1\}^{*} \hspace{.5em} | \hspace{.5em} R_{SHA256}(i,w) = true \}$
*** DONE Example: 3-factorization (Example 118 MoonMath)
/Given an instance field element $x_4$ there are three witness factors $x_1,x_2,x_3.$/

- *Alphabet*:
  - $\Sigma_I = F_{13}$.
  - $\Sigma_W = F_{13}$.
- *Decision function:*
$R_{3,fac\_zk}= (F_{13})^{*} \times (F_{13})^{*} \rightarrow \{true, false\};$ s.t.
$(<i_1,...,i_n>;<w_1,...,w_m>) \mapsto \begin{cases}
\text{True} & n=1, m=3, i_1=w_1 \cdot x_2 \cdot w_3 \\
\text{False} & \text{otherwise.}
\end{cases}$
- *Language*: all strings from $(F_{13})^{*} \times (F_{13})^{*}$ that are mapped to $true$ by the decisio function $R_{3, fac\_zk}$

*** DONE Example: Tiny-jubjub
/Constructive proof is given by a pair $(x_1,x_2) of field elements from F_{13} such that the pair is a point of the Tiny-jubjub curve in it's Edwards form.$/

Reasonable split is to either choose both points as an instance or both as a witness:

=case 1: Both coordinates are instances=

- *Decision Function*:
$R(I;W) =  \begin{cases}
\text{True} & \text{if } 3 \cdot I_{1}^{2} + I_{2}^{2} = 1 + 8 \cdot I_{1}^{2} \cdot I_{2}^{2} \\
\text{False} & \text{otherwise.}
\end{cases}$


=case 2: Both coordinates are witness inputs=
$R(I;W) =  \begin{cases}
\text{True} & \text{if } 3 \cdot W_{1}^{2} + W_{2}^{2} = 1 + 8 \cdot W_{1}^{2} \cdot W_{2}^{2} \\
\text{False} & \text{otherwise.}
\end{cases}$

* IN-PROGRESS Rank-1 Quadratic Constraint Systems (R1CS)

=Definition: R1CS=

Let $F$ be a field.
Let $n,m,k \in N$.
Let $a_{j}^{i}, b_{j}^{i}, c_{j}^{i} \in F$ be constant for every $0 \leq j \leq n+m$ and $1 \leq i \leq k$.
Then Rank-1 Quadratic Constraint System is the following set of $k$ many equations:

$(a_{0}^{1} + \sum_{j=1}^{n}a_{j}^{1} \cdot I_{j} + \sum_{j=1}^{m}a_{n+j}^{1} \cdot W_{j}) \cdot (b_{0}^{1} + \sum_{j=1}^{n}b_{j}^{1} \cdot I_{j} + \sum_{j=1}^{m}b_{n+j}^{1} \cdot W_{j}) = c_{0}^{1} + \sum_{j=1}^{n}c_{j}^{1} \cdot I_{j} + \sum_{j=1}^{m}c_{n+j}^{1} \cdot W_{j}$

$\vdots$

$(a_{0}^{k} + \sum_{j=1}^{n}a_{j}^{k} \cdot I_{j} + \sum_{j=1}^{m}a_{n+j}^{k} \cdot W_{j}) \cdot (b_{0}^{k} + \sum_{j=1}^{n}b_{j}^{k} \cdot I_{j} + \sum_{j=1}^{m}b_{n+j}^{k} \cdot W_{j}) = c_{0}^{k} + \sum_{j=1}^{n}c_{j}^{k} \cdot I_{j} + \sum_{j=1}^{m}c_{n+j}^{k} \cdot W_{j}$

where:

- $k$ is called the *number of constraints*
- each equation is called a *constraint*
- if a pair of strings of field elements $(<I_1,\cdots I_n>;<W_1,\cdots,W_m>)$ satisfies these equations, $<I_1,\cdots,I_n>$ is called an *instance* and $<W_1,\cdots,W_m>$ is called an *witness* of the system.

---

*NOTE : R1CS in vector and matrix notation*

$Ax \odot Bx=Cx$

where:
- $x=(1,I,W) \in F^{1+n+m}$ is an (n+m+1)-dimensional vector.
- $A,B,C$ are $(n+m+1) \times k$-dimensional matrices

---

** DONE Example: R1CS for 3-factorization (Example 120 MoonMath)

Language consists of words $<I_1>;<W_1,W_2,W_3>$ over the alphabet $F_{13}$ s.t. $I_{1}=W_{1} \cdot W_{2} \cdot W_{3}$
Rewriting this as R1CS:

$W_1 \cdot W_2 = W_4 \hspace{2em} \text{constraint 1}$
$W_4 \cdot W_3 = I_1 \hspace{2em} \text{constraint 2}$

---

*NOTE*

R1CS is a system of quadratic equations, therefore expressions like $W_1 \cdot W_2 \cdot W_3$ which contain products of more than two factors (are not quadratic) need to be *flattened* to a quadratic form.
Above we did that by introducing a new variable $W_4$.

The choice of equations is not unique, for example the equvalent R1CS system is:

$W_2 \cdot W_3 = W_4$
$W_1 \cdot W_4 = I_1$

*R1CS* are (generally) not unique descriptions of a problem, many different systems are able to describe the same problem.

---

Now to write the two above equations ($W_{1} \cdot W_{2}=W_{4}, W_{4} \cdot W_{3} = I_{1}$) in the R1CS [[*Rank-1 Quadratic Constraint Systems (R1CS)][general form]], let $n=1, m=4, k=2$ (1 instance input, 4 witness values, 2 constraints):

$(a_{0}^{1} + a_{1}^{1} \cdot I_{1} + \sum_{j=1}^{4}a_{1+j}^{1} \cdot W_{j}) \cdot (b_{0}^{1} + b_{1}^{1} \cdot I_{1} + \sum_{j=1}^{4}b_{1+j}^{1} \cdot W_{j}) = (c_{0}^1 + c_{1}^{1} \cdot I_{1} + \sum_{j=1}^{4}c_{1+j}^{1} \cdot W_{j})$
$(a_{0}^2 + a_{1}^{2} \cdot I_1 + \sum_{j=1}^{4}a_{1+j}^{2} \cdot W_j) \cdot (b_{0}^{2} + b_{1}^{2} \cdot I_{1} + \sum_{j=1}^{4}b_{1+j}^{2} \cdot W_{j}) = (c_{0}^{2} + c_{1}^{2} \cdot I_{1} + \sum_{j=1}^{4}c_{1+j}^{2} \cdot W_{j})$

For values:

$a_{0}^{1}=0 \hspace{.5em} a_{1}^{1}=0 \hspace{.5em} a_{2}^{1}=1 \hspace{.5em} a_{3}^{1}=0 \hspace{.5em} a_{4}^{1}=0 \hspace{.5em} a_{5}^{1}=0$
$a_{0}^{2}=0 \hspace{.5em} a_{1}^{2}=0 \hspace{.5em} a_{2}^{2}=0 \hspace{.5em} a_{3}^{2}=0 \hspace{.5em} a_{4}^{2}=0 \hspace{.5em} a_{5}^{2}=1$

$b_{0}^{1}=0 \hspace{.5em} b_{1}^{1}=0 \hspace{.5em} b_{2}^{1}=0 \hspace{.5em} b_{3}^{1}=1 \hspace{.5em} b_{4}^{1}=0 \hspace{.5em} b_{5}^{1}=0$
$b_{0}^{2}=0 \hspace{.5em} b_{1}^{2}=0 \hspace{.5em} b_{2}^{2}=0 \hspace{.5em} b_{3}^{2}=0 \hspace{.5em} b_{4}^{2}=1 \hspace{.5em} b_{5}^{2}=0$

$c_{0}^{1}=0 \hspace{.5em} c_{1}^{1}=0 \hspace{.5em} c_{2}^{1}=0 \hspace{.5em} c_{3}^{1}=0 \hspace{.5em} c_{4}^{1}=0 \hspace{.5em} c_{5}^{1}=1$
$c_{0}^{2}=0 \hspace{.5em} c_{1}^{2}=1 \hspace{.5em} c_{2}^{2}=0 \hspace{.5em} c_{3}^{2}=0 \hspace{.5em} c_{4}^{2}=0 \hspace{.5em} c_{5}^{2}=0$

In the most general form this becomes:

$(a_{0}^{1} + a_{1}^{1} \cdot I_{1} + a_{2}^{1}W_{1} + a_{3}^{1}W_{2} + a_{4}^{1}W_{3} + a_{5}^{1}W_{4}) \cdot (b_{0}^{1} + b_{1}^{1} \cdot I_{1} + b_{2}^{1}W_{1} + b_{3}^{1}W_{2} + b_{4}^{1}W_{3} + b_{5}^{1}W_{4}) \cdot (c_{0}^{1} + c_{1}^{1} \cdot I_{1} + c_{2}^{1}W_{1} + c_{3}^{1}W_{2} + c_{4}^{1}W_{3} + c_{5}^{1}W_{4})$
$(a_{0}^{2}} + a_{1}^{2}} \cdot I_{1} + a_{2}^{2}}W_{1} + a_{3}^{2}}W_{2} + a_{4}^{2}}W_{3} + a_{5}^{2}}W_{4}) \cdot (b_{0}^{2}} + b_{1}^{2}} \cdot I_{1} + b_{2}^{2}}W_{1} + b_{3}^{2}}W_{2} + b_{4}^{2}}W_{3} + b_{5}^{2}}W_{4}) \cdot (c_{0}^{2}} + c_{1}^{2}} \cdot I_{1} + c_{2}^{2}}W_{1} + c_{3}^{2}}W_{2} + c_{4}^{2}}W_{3} + c_{5}^{2}}W_{4})$


Which simplifies to the target equations.

** TODO Example: R1CS for Tiny-jubjub curve (Example 121 MoonMath)


* TODO Groth16
* TODO PLONK
