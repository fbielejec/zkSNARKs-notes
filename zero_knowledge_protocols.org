#+STARTUP: overview
#+latex_class_options: [14pt]

* DONE Statements
- In the formal language context *statements* provide membership claims.
 - *instances* are constructive proofs of the statements.
** DONE Formal Languages

=General definition: Language=

Let $\Sigma$ be any set. Let $\Sigma^{*}$ be the set of all strings of a finite length $<x_1, \ldots,x_n>$ of elements $x_j \in \Sigma$, including the empty string $<> \in \Sigma^{*}$.
The *language* $L$ is a subset of the set of all finite strings $\Sigma^{*}$.
In this context:
- The set $\Sigma$ is called the *alphabet* of the language *L*.
- Elements from $\Sigma$ are called letters.
- Elements from $L$ are called *words*.
- If there are rules that specify which strings from $\Sigma^{*}$ belong to the language, these rules are called the *grammar* of the language.

** DONE Decision functions

*Decison function $R$*

$R: \hspace{.5em} \Sigma^{*} \rightarrow \{ true, false \}$

decides whether a given string $x \in \Sigma^{*}$ is an element of the language or not.
The associated language can be written as the set off all strings decided by $R$:

$L_R:=\{ x \in \Sigma^{*} \hspace{.5em} | \hspace{.5em} R(x) = true \}$

=Definiton: statement=

*Statement* $S$ is the claim that language $L$ contains a word $x$.
A *proof* for statement $S$ is given by some string $P \in \Sigma^{*}$.
Such proof is *verified* by checking if:

$R(P)=true$

In this case $P$ is called an *instance* of the statement $S$.
*** DONE Example: The empty language (Example 114 MoonMath)
Consider the alphabet $\Sigma=\mathbb{Z}_6$ , where $\mathbb{Z}_6$ is the ring of modular 6 arithmetic as derived in [[file:arithmetics.org::*Example 11 MoonMath (Arithmetic modulo $6$)][Arithmetic modulo $6$]].

- *Alphabet*: $\Sigma = \mathbb{Z}_6 = \{ 0, 1, 2, 3, 4, 5 \}$.
- *Language*: $L = \{ x \in (\mathbb{Z}_6)^* \mid x \times x \equiv 2 \pmod{6} \}$
  - where $x$ is a single element in $\mathbb{Z}_6$
- *Decision Function*:
$R(x) =  \begin{cases}
\text{True} & \text{if } x \times x \equiv 2 \pmod{6}, \\
\text{False} & \text{otherwise.}
\end{cases}$

Since $0^=0, 1^2=1, 2^2=4, 3^2=3, 4^2=4, 5^2=1$ no element has it's square equa to 2 (mod 6), the language is empty.

#+BEGIN_SRC sage :session . :exports both
Z6 = Integers(6)

def R(x):
    """
    Decision function for whether x * x \\equiv 2 mod 6.
    """
    return Z6(x)^2 == Z6(2)

for x in range(6):
    print(f"R({x}) = {R(x)}")
#+END_SRC

#+RESULTS:
: R(0) = False
: R(1) = False
: R(2) = False
: R(3) = False
: R(4) = False
: R(5) = False

*** DONE Example: 3-Factorization (Example 115 MoonMath)
/Language which consists of those elements of the field $F_13$ that can be factored into 3 other elements./

Formalizing the description:
- *Alphabet*: $\Sigma = F_{13}$.
- *Language*: $L_{3,fac} = \{ x_1, x_2, x_3, x_4 \in F_{13}: \hspace{.5em} x_4 = x_1 \cdot x_2 \cdot x_3 \}$.
- *Decision Function*:
$R(<x_1,x_2,x_3,x_4>) =  \begin{cases}
\text{True} & \text{if } x_4 = x_1 \cdot x_2 \cdot x_3 \\
\text{False} & \text{otherwise.}
\end{cases}$,

where:
- $x_1, x_2, x_3, x_4 \in F_{13}$

The string $<2, 12, 4, 5>$ is a constructive proof for the statement that L_{13,fac} contains words:

#+BEGIN_SRC sage :session . :exports both
F13 = GF(13)

def R(x1,x2,x3,x4):
    return F13(x4) == F13(x1)*F13(x2)*F13(x3)

x1=2; x2=12; x3=4; x4=5

# verification of the proof
print(f"R{x1,x2,x3,x4} = {R(x1,x2,x3,x4)}")
#+END_SRC

#+RESULTS:
: R(2, 12, 4, 5) = True
*** DONE Example: Tiny-jubjub Membership (Example 116 MoonMath)
/Language where word are points on the Tiny-jubjub curve (in it's Twisted Edwards form)./

Formalizing the description:
- *Alphabet*: $\Sigma = F_{13}$.
- *Decision Function*:
$R(x_1,x_2) =  \begin{cases}
\text{True} & \text{if } 3 \cdot x_{1}^{2} + x_{2}^{2} = 1 + 8 \cdot x_{1}^{2} \cdot x_{2}^{2} \\
\text{False} & \text{otherwise.}
\end{cases}$
- *Language*:
$L = \{ x_1, x_2 \in F_{13} : \hspace{.5em} R(x_1,x_2) = true \}$

Any of the points on the curve is therefore a constructive proof that the there is a word in the language:

#+BEGIN_SRC sage :session . :exports both
F13 = GF(13)

L_ETJJ = []
for x in F13:
  for y in F13:
    if F13(3)*x^2 + y^2 == 1+ F13(8)*x^2*y^2:
      L_ETJJ.append((x,y))

ETJJ = Set(L_ETJJ)
ETJJ
#+END_SRC

#+RESULTS:
: {(0, 1), (8, 8), (11, 7), (1, 2), (2, 7), (1, 11), (6, 4), (7, 9), (10, 0), (12, 2), (12, 11), (7, 4), (5, 5), (5, 8), (3, 0), (11, 6), (0, 12), (2, 6), (6, 9), (8, 5)}

* DONE Instance and witness
- in the context of a zero-knowledge proof system it is possible to hide parts of the proof instance and still be able to prove the statement.
- the proof is split into a public part called the *instance* and a private part called the *witness*.

=Definition: decision function with an instance and a witness=

$R: \hspace{.5em} \Sigma_{I}^{*} \times \Sigma_{W}^{*} \rightarrow \{\text{true, false} \}; \hspace{.5em} (i,w) \mapsto R(i,w)$

where:
- words are strings $(i,w)\in \Sigma_I^{*} \times \Sigma_W^{*}$ for which $R(i,w)=true$.
- the input $i \in \Sigma_{I}$ is called an instance.
- the input $w \in \Sigma_{W}$ is called a witness.

=Definition: language with an instance and a witness=

$L_R := \{ (i;w) \in \Sigma_{I}^{*} \times \Sigma_{W}^{*} \hspace{.5em} | \hspace{.5em} R(i;w) = true \}$

In this context *statement* $S$ is a claim that given an instance $i$ there is a witness $w$ such that the language $L$ contains a word $(i,w)$.
A constructive proof for $S$ is a string $P=(i,w)$ and it is verified by $R(P)=true$.
*** DONE Example: SHA256 - Knowledge of Preimage (Example 117 MoonMath)
/Given a digest $i$ there is a preimage $w$ such that SHA256(w)=i$/

SHA256 maps arbitary length binary strings to binary strings of length 256:

$\text{SHA256}: \hspace{.5em} | \hspace{.5em} \{0,1\}^{*} \rightarrow \{0,1\}^{256}$

Formal description of the language:

- *Alphabet*:
  - for the set of all instances: $\Sigma_I = \{0,1\}$
  - for the set of all witnesses: $\Sigma_W = \{0,1\}$
- *Decision function:*
$R_{SHA256}: \hspace{.5em} | \hspace{.5em} \{0,1\}^{*} \times \{0,1\}^{*} \rightarrow \{true,false\};$ s.t.
$(i;w) \mapsto \begin{cases}
\text{True} & |i|=256, i=SHA256(w) \\
\text{False} & \text{otherwise.}
\end{cases}$
- *Language*:
$L_{SHA256} := \{ (i;w) \in \{0,1\}^{*} \times \{0,1\}^{*} \hspace{.5em} | \hspace{.5em} R_{SHA256}(i,w) = true \}$
*** DONE Example: 3-factorization (Example 118 MoonMath)
/Given an instance field element $x_4$ there are three witness factors $x_1,x_2,x_3$/

- *Alphabet*:
  - $\Sigma_I = F_{13}$.
  - $\Sigma_W = F_{13}$.
- *Decision function:*
$R_{3.fac\_zk}= (F_{13})^{*} \times (F_{13})^{*} \rightarrow \{true, false\};$ s.t.
$(<i_1,...,i_n>;<w_1,...,w_m>) \mapsto \begin{cases}
\text{True} & n=1, m=3, i_1=w_1 \cdot x_2 \cdot w_3 \\
\text{False} & \text{otherwise.}
\end{cases}$
- *Language*: all strings from $(F_{13})^{*} \times (F_{13})^{*}$ that are mapped to $true$ by the decision function $R_{3.fac\_zk}$:
$L_{3.fac\_zk}=\{ (i;w) \in \Sigma_{I}^{*} \times \Sigma_{W}^{*} \hspace{.5em} | \hspace{.5em} R_{3.fac\_zk}(i;w) = true \}$

*** DONE Example: Tiny-jubjub (Example 119 MoonMath)
/Constructive proof is given by a pair $(x_1,x_2)$ of field elements from $F_{13}$ such that the pair is a point of the Tiny-jubjub curve in it's Edwards form./

Reasonable split is to either choose both points as an instance or both as a witness:

=case 1: Both coordinates are instances=

*Decision Function*:
$R(I;W) =  \begin{cases}
\text{True} & \text{if } 3 \cdot I_{1}^{2} + I_{2}^{2} = 1 + 8 \cdot I_{1}^{2} \cdot I_{2}^{2} \\
\text{False} & \text{otherwise.}
\end{cases}$


=case 2: Both coordinates are witness inputs=

*Decision Function*:

$R(I;W) =  \begin{cases}
\text{True} & \text{if } 3 \cdot W_{1}^{2} + W_{2}^{2} = 1 + 8 \cdot W_{1}^{2} \cdot W_{2}^{2} \\
\text{False} & \text{otherwise.}
\end{cases}$

* DONE Rank-1 Quadratic Constraint Systems (R1CS)

=Definition: R1CS=

Let $F$ be a field.
Let $n,m,k \in N$.
Let $a_{j}^{i}, b_{j}^{i}, c_{j}^{i} \in F$ be constant for every $0 \leq j \leq n+m$ and $1 \leq i \leq k$.
Then Rank-1 Quadratic Constraint System is the following set of $k$ many equations:

$(a_{0}^{1} + \sum_{j=1}^{n}a_{j}^{1} \cdot I_{j} + \sum_{j=1}^{m}a_{n+j}^{1} \cdot W_{j}) \cdot (b_{0}^{1} + \sum_{j=1}^{n}b_{j}^{1} \cdot I_{j} + \sum_{j=1}^{m}b_{n+j}^{1} \cdot W_{j}) = c_{0}^{1} + \sum_{j=1}^{n}c_{j}^{1} \cdot I_{j} + \sum_{j=1}^{m}c_{n+j}^{1} \cdot W_{j}$

$\vdots$

$(a_{0}^{k} + \sum_{j=1}^{n}a_{j}^{k} \cdot I_{j} + \sum_{j=1}^{m}a_{n+j}^{k} \cdot W_{j}) \cdot (b_{0}^{k} + \sum_{j=1}^{n}b_{j}^{k} \cdot I_{j} + \sum_{j=1}^{m}b_{n+j}^{k} \cdot W_{j}) = c_{0}^{k} + \sum_{j=1}^{n}c_{j}^{k} \cdot I_{j} + \sum_{j=1}^{m}c_{n+j}^{k} \cdot W_{j}$

where:

- $k$ is called the *number of constraints*.
- Each equation is called a *constraint*.
- If a pair of strings of field elements $(<I_1,\cdots I_n>;<W_1,\cdots,W_m>)$ satisfies these equations, $<I_1,\cdots,I_n>$ is called an *instance* and $<W_1,\cdots,W_m>$ is called a *witness* of the system.

---

*NOTE : R1CS in vector and matrix notation*

$A\mathbf{x} \odot B\mathbf{x}=C\mathbf{x}$

where:
- $\mathbf{x}=(1,I,W) \in F^{1+n+m}$ is an $(n+m+1)$-dimensional vector.
- $A,B,C$ are $(n+m+1) \times k$-dimensional matrices

---

** DONE Example: R1CS for 3-factorization (Example 120 MoonMath)

Language consists of words $<I_1>;<W_1,W_2,W_3>$ over the alphabet $F_{13}$ s.t. $I_{1}=W_{1} \cdot W_{2} \cdot W_{3}$
Rewriting this as R1CS:

$W_1 \cdot W_2 = W_4 \hspace{2em} \text{constraint 1}$
$W_4 \cdot W_3 = I_1 \hspace{2em} \text{constraint 2}$

---

*NOTE*

R1CS is a system of quadratic equations, therefore expressions like $W_1 \cdot W_2 \cdot W_3$ which contain products of more than two factors (are not quadratic) need to be *flattened* to a quadratic form.
Above we did that by introducing a new variable $W_4$.
The choice of equations is not unique, for example the equvalent R1CS system is:

$W_2 \cdot W_3 = W_4$
$W_1 \cdot W_4 = I_1$

It follows that *R1CS* are (generally) not unique descriptions of a problem, as many different systems are able to describe the same problem.

---

Now to write the two above equations ($W_{1} \cdot W_{2}=W_{4}, W_{4} \cdot W_{3} = I_{1}$) in the R1CS [[*Rank-1 Quadratic Constraint Systems (R1CS)][general form]], let $n=1, m=4, k=2$ (1 instance input, 4 witness values, 2 constraints):

$(a_{0}^{1} + a_{1}^{1} \cdot I_{1} + \sum_{j=1}^{4}a_{1+j}^{1} \cdot W_{j}) \cdot (b_{0}^{1} + b_{1}^{1} \cdot I_{1} + \sum_{j=1}^{4}b_{1+j}^{1} \cdot W_{j}) = (c_{0}^1 + c_{1}^{1} \cdot I_{1} + \sum_{j=1}^{4}c_{1+j}^{1} \cdot W_{j})$
$(a_{0}^2 + a_{1}^{2} \cdot I_1 + \sum_{j=1}^{4}a_{1+j}^{2} \cdot W_j) \cdot (b_{0}^{2} + b_{1}^{2} \cdot I_{1} + \sum_{j=1}^{4}b_{1+j}^{2} \cdot W_{j}) = (c_{0}^{2} + c_{1}^{2} \cdot I_{1} + \sum_{j=1}^{4}c_{1+j}^{2} \cdot W_{j})$

For values:

$a_{0}^{1}=0 \hspace{.5em} a_{1}^{1}=0 \hspace{.5em} a_{2}^{1}=1 \hspace{.5em} a_{3}^{1}=0 \hspace{.5em} a_{4}^{1}=0 \hspace{.5em} a_{5}^{1}=0$
$a_{0}^{2}=0 \hspace{.5em} a_{1}^{2}=0 \hspace{.5em} a_{2}^{2}=0 \hspace{.5em} a_{3}^{2}=0 \hspace{.5em} a_{4}^{2}=0 \hspace{.5em} a_{5}^{2}=1$

$b_{0}^{1}=0 \hspace{.5em} b_{1}^{1}=0 \hspace{.5em} b_{2}^{1}=0 \hspace{.5em} b_{3}^{1}=1 \hspace{.5em} b_{4}^{1}=0 \hspace{.5em} b_{5}^{1}=0$
$b_{0}^{2}=0 \hspace{.5em} b_{1}^{2}=0 \hspace{.5em} b_{2}^{2}=0 \hspace{.5em} b_{3}^{2}=0 \hspace{.5em} b_{4}^{2}=1 \hspace{.5em} b_{5}^{2}=0$

$c_{0}^{1}=0 \hspace{.5em} c_{1}^{1}=0 \hspace{.5em} c_{2}^{1}=0 \hspace{.5em} c_{3}^{1}=0 \hspace{.5em} c_{4}^{1}=0 \hspace{.5em} c_{5}^{1}=1$
$c_{0}^{2}=0 \hspace{.5em} c_{1}^{2}=1 \hspace{.5em} c_{2}^{2}=0 \hspace{.5em} c_{3}^{2}=0 \hspace{.5em} c_{4}^{2}=0 \hspace{.5em} c_{5}^{2}=0$

In the most general form this becomes:

$(a_{0}^{1} + a_{1}^{1} \cdot I_{1} + a_{2}^{1}W_{1} + a_{3}^{1}W_{2} + a_{4}^{1}W_{3} + a_{5}^{1}W_{4}) \cdot (b_{0}^{1} + b_{1}^{1} \cdot I_{1} + b_{2}^{1}W_{1} + b_{3}^{1}W_{2} + b_{4}^{1}W_{3} + b_{5}^{1}W_{4}) \cdot (c_{0}^{1} + c_{1}^{1} \cdot I_{1} + c_{2}^{1}W_{1} + c_{3}^{1}W_{2} + c_{4}^{1}W_{3} + c_{5}^{1}W_{4})$
$(a_{0}^{2}} + a_{1}^{2}} \cdot I_{1} + a_{2}^{2}}W_{1} + a_{3}^{2}}W_{2} + a_{4}^{2}}W_{3} + a_{5}^{2}}W_{4}) \cdot (b_{0}^{2}} + b_{1}^{2}} \cdot I_{1} + b_{2}^{2}}W_{1} + b_{3}^{2}}W_{2} + b_{4}^{2}}W_{3} + b_{5}^{2}}W_{4}) \cdot (c_{0}^{2}} + c_{1}^{2}} \cdot I_{1} + c_{2}^{2}}W_{1} + c_{3}^{2}}W_{2} + c_{4}^{2}}W_{3} + c_{5}^{2}}W_{4})$

Which simplifies to the target equations after substituting the values above.

** DONE Example: R1CS for Tiny-jubjub curve (Example 121 MoonMath)
Language consists of words $<I_1,I_2>$ over the alphabet $F_{13}$ s.t. $3\cdot I_{1}^{2} + I_{2}^{2}=1+8\cdot I_{1}^{2} \cdot I_{2}^{2}$

---

*NOTE*

#+BEGIN_SRC sage :session . :exports both
F=GF(13)
F(-3) == F(10)
F(-1) == F(12)
#+END_SRC

#+RESULTS:
: True
: True

---

We start by rewriting the defining equation:

$1+8\cdot I_{1}^{2} \cdot I_{2}^{2} +10 \cdot I_{1}^{2} +12 \cdot I_{2}^{2}  = 0$

Now to express it as R1CS we introduce new variables that constrain the intermediate steps in the computation.
One possible choice is to declare all as witness values:

$I_{1} \cdot I_{1} = W_{1} \hspace{2em} \text{constraint 1}$
$I_{2} \cdot I_{2} = W_{2}  \hspace{2em} \text{constraint 2}$
$(8 \cdot W_{1}) \cdot W_{2} = W_{3} \hspace{2em} \text{constraint 3}$
$(12 \cdot W_{2} + W_{3} +10 \cdot W_{1} +1 ) \cdot 1 = 0 \hspace{2em} \text{constraint 4}$

For the parameters $n=2, m=3, k=4$ and the following values:

$a_{0}^{1}=0 \hspace{.5em} a_{1}^{1}=0 \hspace{.5em} a_{2}^{1}=1 \hspace{.5em} a_{3}^{1}=0 \hspace{.5em} a_{4}^{1}=0 \hspace{.5em} a_{5}^{1}=0$
$a_{0}^{2}=0 \hspace{.5em} a_{1}^{2}=0 \hspace{.5em} a_{2}^{2}=0 \hspace{.5em} a_{3}^{2}=0 \hspace{.5em} a_{4}^{2}=0 \hspace{.5em} a_{5}^{2}=0$
$a_{0}^{3}=0 \hspace{.5em} a_{1}^{3}=0 \hspace{.5em} a_{2}^{4}=0 \hspace{.5em} a_{3}^{3}=0 \hspace{.5em} a_{4}^{3}=0 \hspace{.5em} a_{5}^{3}=0$
$a_{0}^{4}=1 \hspace{.5em} a_{1}^{4}=0 \hspace{.5em} a_{2}^{4}=0 \hspace{.5em} a_{3}^{4}=10 \hspace{.5em} a_{4}^{4}=12 \hspace{.5em} a_{5}^{4}=1$

$b_{0}^{1}=0 \hspace{.5em} b_{1}^{1}=1 \hspace{.5em} b_{2}^{1}=0 \hspace{.5em} b_{3}^{1}=1 \hspace{.5em} b_{4}^{1}=0 \hspace{.5em} b_{5}^{1}=0$
$b_{0}^{2}=0 \hspace{.5em} b_{1}^{2}=0 \hspace{.5em} b_{2}^{2}=1 \hspace{.5em} b_{3}^{2}=0 \hspace{.5em} b_{4}^{2}=0 \hspace{.5em} b_{5}^{2}=0$
$b_{0}^{3}=0 \hspace{.5em} b_{1}^{3}=0 \hspace{.5em} b_{2}^{3}=0 \hspace{.5em} b_{3}^{3}=0 \hspace{.5em} b_{4}^{3}=1 \hspace{.5em} b_{5}^{3}=0$
$b_{0}^{4}=1 \hspace{.5em} b_{1}^{4}=0 \hspace{.5em} b_{2}^{4}=0 \hspace{.5em} b_{3}^{4}=0 \hspace{.5em} b_{4}^{4}=1 \hspace{.5em} b_{5}^{4}=0$

$c_{0}^{1}=0 \hspace{.5em} c_{1}^{1}=0 \hspace{.5em} c_{2}^{1}=0 \hspace{.5em} c_{3}^{1}=1 \hspace{.5em} c_{4}^{1}=0 \hspace{.5em} c_{5}^{1}=0$
$c_{0}^{2}=0 \hspace{.5em} c_{1}^{2}=0 \hspace{.5em} c_{2}^{2}=0 \hspace{.5em} c_{3}^{2}=0 \hspace{.5em} c_{4}^{2}=1 \hspace{.5em} c_{5}^{2}=0$
$c_{0}^{3}=0 \hspace{.5em} c_{1}^{3}=0 \hspace{.5em} c_{2}^{3}=0 \hspace{.5em} c_{3}^{3}=0 \hspace{.5em} c_{4}^{3}=0 \hspace{.5em} c_{5}^{3}=1$
$c_{0}^{4}=0 \hspace{.5em} c_{1}^{4}=0 \hspace{.5em} c_{2}^{4}=0 \hspace{.5em} c_{3}^{4}=0 \hspace{.5em} c_{4}^{4}=0 \hspace{.5em} c_{5}^{4}=0$

** DONE Exercise: R1CS for Edwards Addition on the Tiny-jubjub curve (Exercise 99 and 100 MoonMath)

---

*NOTE*

A *Twisted Edwards Curve* is a generalization of Edwards curves, defined over a field $\mathbb{F}$ by the equation:

$E_{a,d}: a\cdot x^2 + y^2 = 1 + d \cdot x^2 \cdot y^2$

where:
- $a,d \in \mathbb{F}$
- $a \neq d$  and $ad(a - d) \neq 0$.

Key feature of the curves in such a form is their *Unified Addition Law* (which works for both addition and point doubling):

$(x_1, y_1) + (x_2, y_2) = \left( \frac{x_1y_2 + y_1x_2}{1 + dx_1x_2y_1y_2}, \frac{y_1y_2 - ax_1x_2}{1 - dx_1x_2y_1y_2} \right)$

---

/Define an instance alphabet $\Sigma_I$, a witness alphabet $\Sigma_W$ and a decision function $R_{add}$ such that a string $(i;w) \in \Sigma_{I}^{*} \times \Sigma_{W}^{*}$ is a word in $L_{add}$ if and only if $i$ is a pair of curve points on the Tiny-jubjub curve in Edwards form and $w$ is a sum of those points/.

=Instance alphabet=

*Instance alphabet* in this case is the set of all possible pairs of field elements from $F_{13}$ (potential affine coordinates):

$\Sigma_{I} = \hspace{.5em} \{ (x_{1},x_{2}): \hspace{.5em} x_{1},x_{2}} \in F_{13} \}=(F_{13})^{2}$

=Witness alphabet=

Similarly the *Witness alphabet* is the set of all possible points:

$\Sigma_{W} = (F_{13})^{2}$

=Decision function=

Maps an instance (a pair of points with coordinates in $F_{13}$) and a witness (a point) to /true/ if the instance points sum to the witness point on the Tinyy-jubjub curve (using Edwards group law):

$R_{add}: \hspace{.5em} ((F_{13})^2,(F_{13})^2)^{*} \times ((F_{13})^2)^{*}  \rightarrow \{ true, false \};$

$(<I_1,I_2,I_3,I_4>;<W_1.W_2>) \mapsto \begin{cases}
\text{True} & (W_{1}, W_{2}) = \left( \frac{I_{1} \cdot I_{4} + I_{2} \cdot I_{3}}{1 + d \cdot I_{1} \cdot I_{3} \cdot I_{2} \cdot I_{4}}, \frac{I_{2} \cdot I_{4} - a \cdot I_{1} \cdot I_{3}}{1 - d \cdot I_{1} \cdot I_{3} \cdot I_{2} \cdot I_{4}} \right) \\
\text{False} & \text{else}
\end{cases}$

/Choose some instance $i \in \Sigma_{I}^{*}$ and provide a constructive proof for the statement "There is a witness $w \in \Sigma_{W}^{*}$ such that $(i;w)$ is a word in $L_{add}$"/

#+BEGIN_SRC sage :session . :exports both
import itertools

F13 = GF(13)
a = F13(3)
d = F13(8) # satisfies curve non-singularity requirements (a \neq d, a*d*(a-d) \neq 0)

tjj = Set([p for p in itertools.product(F13, F13) if a * p[0]^2 + p[1]^2 == 1 + d * p[0]^2 * p[1]^2])
tjj

def add(P, Q):
    if P == (0,1,0):
        return Q
    if Q == (0,1,0):
        return P

    x1, y1 = P[0], P[1]
    x2, y2 = Q[0], Q[1]

    numerator_x = (x1*y2 + y1*x2)
    denominator_x = (1 + d*x1*x2*y1*y2)

    numerator_y = (y1*y2 - a*x1*x2)
    denominator_y = (1 - d*x1*x2*y1*y2)

    x3 = numerator_x / denominator_x
    y3 = numerator_y / denominator_y

    return (x3, y3)

def R_add(P,Q,R):
    return R == add(P,Q)

P=(8,8)
Q=(1,2)
R=add(P,Q)

print(f"R({P,Q,R}) = {R_add(P,Q,R)}")
#+END_SRC

#+RESULTS:
: {(0, 1), (8, 8), (11, 7), (1, 2), (2, 7), (1, 11), (6, 4), (7, 9), (10, 0), (12, 2), (12, 11), (7, 4), (5, 5), (5, 8), (3, 0), (11, 6), (0, 12), (2, 6), (6, 9), (8, 5)}
: R(((8, 8), (1, 2), (1, 11))) = True

$w=(1,11)$ is a witness such that together with an instance $i=((8,8),(1,2))$ $(i;w)$ is a word in $L_{add}$.

/Find some instance  $i \in \Sigma_{I}^{*}$ such that $i$ has no knowledge proof in $L_{add}$/

#+BEGIN_SRC sage :session . :exports both
done = False
for i_1 in range(1,12):
  for i_2 in range(1,12):
    for i_3 in range(1,12):
      for i_4 in range(1,12):
        P=(i_1,i_2);
        Q=(1_3,i_4);
        R=add(P,Q);
        if not (R in tjj):
          print(f"add({P,Q}) = {add(P,Q)}");
          done = True;
          break;
      if done: break
    if done: break
  if done: break
#+END_SRC

#+RESULTS:
: add(((1, 1), (13, 1))) = (1, 1)

/Define an R1CS such that the words in $L_add$ are in 1:1 correspondence with the solutions to this R1CS./

We need to write the following computation as an R1CS:

$(W_1, W_2) = \left( \frac{I_{1} \cdot I_{4} + I_{2} \cdot I_{3}}{1 + d \cdot I_{1} \cdot I_{3} \cdot I_{2} \cdot I_{4}}, \frac{I_{2} \cdot I_{4} - a \cdot I_{1} \cdot I_{3}}{1 - d \cdot I_{1} \cdot I_{3} \cdot I_{2} \cdot I_{4}} \right)$

$\begin{cases}
W_1 \cdot (1 + d \cdot I_{1} \cdot I_{3} \cdot I_{2} \cdot I_{4} ) = I_{1} \cdot I_{4} + I_{2} \cdot I_{3} \\
W_2 \cdot (1 - d \cdot I_{1} \cdot I_{3} \cdot I_{2} \cdot I_{4}) = I_{2} \cdot I_{4} - a \cdot I_{1} \cdot I_{3}
\end{cases}$

$\begin{cases}
I_1 \cdot I_4 = W_3 \\
I_2 \cdot I_3 = W_4 \\
I_1 \cdot I_3 = W_5 \\
I_2 \cdot I_4 = W_6 \\
(d W_3) \cdot W_4 = W_7 \\
W_1 \cdot (1 + W_7) = W_3 + W_4 \\
W_2 \cdot (1 - W_7) = W_6 - aW_5 \\
\end{cases}$

We have an R1CS with $n=4$ instances, $m=7$ witness values (2 field values for the sum point and 5 intermediate witness values) and $k=7$ constraints.

For example, for the first constraint we have (unofficial notation):

$A[0] \odot \mathbf{X} \times B[0] \odot \mathbf{X} = C[0] \odot \mathbf{X}$

where:

- $A[0], B[0], C[0]$ is the first row of the coefficient matrix.
- $\odot$ denotes element-wise multiplication (Hadamard product).
- $\times$ is standard multiplication.
- The columns of the $A,B$ and $C$ follow this order:
| constant | I_1 | I_2 | I_3 | I_4 | W_1 | W_2 | W_3 | W_4 | W_5 | W_6 | W_7 |

$A[0] \odot \mathbf{x} = \begin{bmatrix}
0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0
\end{bmatrix} \odot  \begin{bmatrix} 1 \\ I_{1} \\ I_{2} \\ I_{3} \\ I_{4} \\ W_{1} \\ W_{2} \\ W_{3} \\ W_{4} \\ W_{5} \\ W_{6} \\ W_{7} \end{bmatrix} = 1 \times I_{1}$

$B[0] \odot \mathbf{X} = \begin{bmatrix}
0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0
\end{bmatrix} \odot  \begin{bmatrix} 1 \\ I_{1} \\ I_{2} \\ I_{3} \\ I_{4} \\ W_{1} \\ W_{2} \\ W_{3} \\ W_{4} \\ W_{5} \\ W_{6} \\ W_{7} \end{bmatrix} = 1 \times I_{4}$

$C[0] \odot \mathbf{X} = \begin{bmatrix}
0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0
\end{bmatrix} \odot  \begin{bmatrix} 1 \\ I_{1} \\ I_{2} \\ I_{3} \\ I_{4} \\ W_{1} \\ W_{2} \\ W_{3} \\ W_{4} \\ W_{5} \\ W_{6} \\ W_{7} \end{bmatrix} = 1 \times W_{3}$

Using maxima to simplify the calculations for all of the quadratic constraints:

#+BEGIN_SRC maxima :exports both :results output replace
/* Define the column vector X */
X: matrix(
  [1],
  [I1], [I2], [I3], [I4],
  [W1], [W2], [W3], [W4], [W5], [W6], [W7]
);

/* Initialize zero matrices with 7 rows (equations) and 12 columns (constant + vars) */
A: zeromatrix(7, 12)$
B: zeromatrix(7, 12)$
C: zeromatrix(7, 12)$

/*NOTE: maxima uses 1-based indexing!*/

/* Constraint 1: I1*I4 = W3 */
A[1][2]: 1$  /* I1 */
B[1][5]: 1$  /* I4 */
C[1][8]: 1$  /* W3 */

print(A[1].X * B[1].X, "=", C[1].X);

/* Constraint 2: I2*I3 = W4 */
A[2][3]: 1$  /* I2 */
B[2][4]: 1$  /* I3 */
C[2][9]: 1$  /* W4 */

print(A[2].X * B[2].X, "=", C[2].X);

/* Constraint 3: I1*I3 = W5 */
A[3][2]: 1$  /* I1 */
B[3][4]: 1$  /* I3 */
C[3][10]: 1$ /* W5 */

print(A[3].X * B[3].X, "=", C[3].X);

/* Equation 4: I2*I4 = W6 */
A[4][3]: 1$  /* I2 */
B[4][5]: 1$  /* I4 */
C[4][11]: 1$ /* W6 */

print(A[4].X * B[4].X, "=", C[4].X);

/* Equation 5: (8 W3)*W4 = W7 */
A[5][8]: 8$  /* 8*W3 */
B[5][9]: 1$  /* W4 */
C[5][12]: 1$ /* W7 */

print(A[5].X * B[5].X, "=", C[5].X);

/* Equation 6: W1*(1 + W7) = W3 + W4 */
A[6][6]: 1$   /* W1 */
B[6][1]: 1$   /* 1 */
B[6][12]: 1$  /* W7 */
C[6][8]: 1$   /* W3 */
C[6][9]: 1$   /* W4 */

print(A[6].X * B[6].X, "=", C[6].X);

/* Equation 7: W2*(1 - W7) = W6 - 3W5 */
A[7][7]: 1$   /* W2 */
B[7][1]: 1$   /* 1 */
B[7][12]: -1$ /* -W7 */
C[7][11]: 1$  /* W6 */
C[7][10]: -3$ /* -3W5 */

print(A[7].X * B[7].X, "=", C[7].X);

/* Display the matrices */
print("Matrix A:")$
disp(A)$
print("Matrix B:")$
disp(B)$
print("Matrix C:")$
disp(C)$

#+END_SRC

#+RESULTS:
#+begin_example
I1 I4 = W3
I2 I3 = W4
I1 I3 = W5
I2 I4 = W6
8 W3 W4 = W7
W1 (W7 + 1) = W4 + W3
W2 (1 - W7) = W6 - 3 W5
Matrix A:
                    [ 0  1  0  0  0  0  0  0  0  0  0  0 ]
                    [                                    ]
                    [ 0  0  1  0  0  0  0  0  0  0  0  0 ]
                    [                                    ]
                    [ 0  1  0  0  0  0  0  0  0  0  0  0 ]
                    [                                    ]
                    [ 0  0  1  0  0  0  0  0  0  0  0  0 ]
                    [                                    ]
                    [ 0  0  0  0  0  0  0  8  0  0  0  0 ]
                    [                                    ]
                    [ 0  0  0  0  0  1  0  0  0  0  0  0 ]
                    [                                    ]
                    [ 0  0  0  0  0  0  1  0  0  0  0  0 ]
Matrix B:
                   [ 0  0  0  0  1  0  0  0  0  0  0   0  ]
                   [                                      ]
                   [ 0  0  0  1  0  0  0  0  0  0  0   0  ]
                   [                                      ]
                   [ 0  0  0  1  0  0  0  0  0  0  0   0  ]
                   [                                      ]
                   [ 0  0  0  0  1  0  0  0  0  0  0   0  ]
                   [                                      ]
                   [ 0  0  0  0  0  0  0  0  1  0  0   0  ]
                   [                                      ]
                   [ 1  0  0  0  0  0  0  0  0  0  0   1  ]
                   [                                      ]
                   [ 1  0  0  0  0  0  0  0  0  0  0  - 1 ]
Matrix C:
                   [ 0  0  0  0  0  0  0  1  0   0   0  0 ]
                   [                                      ]
                   [ 0  0  0  0  0  0  0  0  1   0   0  0 ]
                   [                                      ]
                   [ 0  0  0  0  0  0  0  0  0   1   0  0 ]
                   [                                      ]
                   [ 0  0  0  0  0  0  0  0  0   0   1  0 ]
                   [                                      ]
                   [ 0  0  0  0  0  0  0  0  0   0   0  1 ]
                   [                                      ]
                   [ 0  0  0  0  0  0  0  1  1   0   0  0 ]
                   [                                      ]
                   [ 0  0  0  0  0  0  0  0  0  - 3  1  0 ]
#+end_example

* DONE R1CS Satisfiability
- Rank-1 Constraint Systems define [[*Formal Languages][Formal Languages]].
- Every R1CS over a field $F$ defines a decision function over the alphabet $\Sigma_{I} \times \Sigma_{W}=F \times F$ in the following way:

$R_{R1CS}: \hspace{.5em} (F)^{*} \times (F)^{*} \rightarrow {true,false};$

$(I;W) \mapsto
\begin{cases}
\text{True} & \text{if } (I;W) \text{ satisfies R1CS}, \\
\text{False} & \text{otherwise.}
\end{cases}$

This is equivalent to saying that every R1CS defines a formal language:
- The grammar of the language is the constraints.
- words are solutions to the constraints equations.
- *statement* is a knowledge claim: "Given instance $I$ there is a witness $W$ such that $(I;W)$ is a solution to the R1CS."

---

*NOTE: R1CS satisfiability*

- Every R1CS defines it's own language (since the constraints, aka the grammar, can be different).
- This is why often times we talk about another language called *R1CS satisfiability*, that is a *union* of the R1CS languages that define the problem:
  - Let the alphabet $\Sigma=F$ be a field.
  - the R1CS satisfiability language* is defined as follows:

$L_{R1CS\_SAT(F)} = \{ (i;w) \in \Sigma^{*} \times \Sigma^{*} \hspace{.5em} | \hspace{.5em} \text{there is a R1CS R such that } R(i;w) = true  \}$

---
** DONE Example: 3-Factorization
To prove a statement "There exists a witness $W$ such that $(I_{1};W)$ is a word in $L_{3.fac\_zk}$" constructively, a proof has to be provide a solution to [[*Example: R1CS for 3-factorization (Example 120 MoonMath)][R1CS for 3-factorization]].
That is an assignment to all witness variables $W_1,W_2,W_3,W_4$.

#+BEGIN_SRC sage :session . :exports both
F=GF(13)

def R(I,W):
  i1 = I;
  w1,w2,w3,w4 = W[0],W[1],W[2],W[3]

  constraint1 = F(w1)*F(w2)==F(w4);
  constraint2 = F(w4)*F(w3)==F(i1);
  return (constraint1 & constraint2)

I=(11);W=(2,3,4,6);

print(f"R(I={I};W={W}) = {R(I,W)}")

# another proof (factorization is not unique in a field in general)
R((11),(3,5,12,2))

#+END_SRC

#+RESULTS:
: R(I=11;W=(2, 3, 4, 6)) = True
: True

* IN-PROGRESS Algebraic Circuits
- Rank-1 Constraint Systems are quadratic equations such that solutions are knowledge proofs for the existence of words in associated languages.
- No general methods are known that solve systems of quadratic equations efficiently.
- Auxiliary information is needed to help compute solutions efficiently.
- A class of [[*Decision functions][Decision Functions]] called *algebraic circuits* bridges that gap.
  - Every algebraic circuit defines an associated R1CS and also provides an efficient way to compute solutions for that R1CS.

=Definition: Algebraic Circuit=

A directed acyclic multi-graph $\mathbb{C}(\mathbb{F})$ over field $\mathbb{F}$ is called an *algebraic circuit* if the following holds:

- The set of edges has a total order.
- Every source node has a label that represents either a variable or a constant from the field
$\mathbb{F}$.
- Every sink node has exactly one incoming edge and a label that represents either a variableor a constant from the field $\mathbb{F}$.
- Every node that is neither a source nor a sink has exactly two incoming edges and a label
from the set $\{+,*\}$ that represents either addition or multiplication in $\mathbb{F}$.
- All outgoing edges from a node have the same label.
- Outgoing edges from a node with a label that represents a variable have a label.
- Outgoing edges from a node with a label that represents multiplication have a label, if
there is at least one labeled edge in both input paths.
- All incoming edges to sink nodes have a label.
- If an edge has two labels $S_i$ and $S_j$ it gets a new label $S_i = S_j$ .
- No other edge has a label.
- Incoming edges to labeled sink nodes, where the label is a constant $c \in \mathbb{F}$ are labeled with the same constant. Every other edge label is taken from the set $\{W, I\}$ and indexed compatible with the order of the edge set.

where:
- Source nodes are the inputs to the circuit and either represent variables or constants.
- Sink nodes represent termination points of the circuit and are either output variables or constants.
  - Constant sink nodes enforce computational outputs to take on certain values.

** DONE Example: Generalized 3-factorization SNARK (Example 124 MoonMath)

Revisiting the [[*Example: 3-factorization (Example 118 MoonMath)][zero-knowledge 3-factorization]] problem, let's consider the following function:

$f_{3.fac} : \mathbb{F}_{13} \times \mathbb{F}_{13} \mathbb{F}_{13} \rightarrow \mathbb{F}_{13}; \hspace{.5em} (x_1,x_2,x_3) \rightarrow x_1 \cdot x_2 \cdot x_3$

Using it we can describe the problem in the following way:

"Given an instance $I_1 \in \mathbb{F}_{13}$ a valid witness consists of three values $W_1,W_2,W_3$ from \mathbb{F}_13 such that $f_3.fac(W_1,W_2,W_3)=I_1$ (valid witness is a preimage of $f_{3.fac}$ at the point I1)"

This function can be transformed into an algebraic circuit over $\mathbb{F}_13$ as follows:

\begin{align*}
f_{3.fac}(x_1,x_2,x_3) & = x_1 \cdot x_2 \cdot x_3 \\
                       & = (x_1 \cdot x_2 ) \cdot x_3 \\
                       & = MUL(MUL(x_1,x_2),x_3)
\end{align*}

Following the [[*Algebraic Circuits][Algebraic Circuits]] definition:
- We first constrain the variables to edge labels $W_1 = x_1$, W_2 = x_2, W_3 = x_3$ as well as I_1 = $f_{3.fac\_zk}$.
  - The order follows depth-first right-to-left traversal algorithm.
- We then rewrite the operator representation of $f_{3.fac}$ into circuit nodes.

We get the following:

#+BEGIN_SRC dot :file 3.fac_zk.png :exports results
digraph G1 {
        graph [forcelabels=true,
                nodesep=2.0,
                splines=ortho
        ];
        n1	[label=x_2,
                shape=box];
        n3	[label="*"];
        n1 -> n3	[xlabel="W_2 "];
        n5	[label="*"];
        n3 -> n5	[label=W_4];
        n2	[label=x_1,
                shape=box];
        n2 -> n3	[xlabel=" W_1"];
        n6	[label="f_(3.fac_zk)",
                shape=box];
        n5 -> n6	[label=" I_1"];
        n4	[label=x_3,
                shape=box];
        n4 -> n5	[label=" W_3"];
}
#+END_SRC

#+RESULTS:
[[file:3.fac_zk.png]]

** DONE Example: Tiny-jubjub membership (Example 125 MoonMath)

A pair of field elements $(x,y) \in \mathbb{F}_{13}$ is a curve point if:

$3 \cdot x^2 + y^2 = 1+ 8 \cdot x^2 \cdot y^2$

To transform the following into an algebraic circuit:

\begin{align*}
3 \cdot x^2 + y^2 & = 1 + 8 \cdot x^2 \cdot y^2 \\
0 & = 1 + 8 \cdot x^2 \cdot y^2 - 3 \cdot x^2 - y^2 \\
0 & = 1 + 8 \cdot x^2 \cdot y^2 +10 \cdot x^2 + 12 y^2 \\
\end{align*}

We then use this expression to define a function such that all points on the Tiny-jubjub curve are preimages of this function at 0:

$f_{tiny\_jj}: \mathbb{F}_{13} \times \mathbb{F}_{13} \rightarrow \mathbb{F}_{13}; \hspace{.5em} (x,y) \mapsto  1 + 8 \cdot x^2 \cdot y^2 +10 \cdot x^2 + 12 y^2$

Every pair of field elements $(x,y) \in \mathbb{F}_{13}^{2}$ with $f_{tiny\_jj}=0$ is a point on the curve.
The preimage $f_{tiny\_jj}^{-1}(0)$ is therefore a complete description of the curve (there are no other curve points).

To transform this function into an algebraic circuit:

\begin{align*}
f_{tiny\_jj} & = 1 + 8 \cdot x^2 \cdot y^2 +10 \cdot x^2 + 12 y^2 \\
             & = ((8 \cdot ((x \cdot x) \cdot (y \cdot y))) + (1 + 10 \cdot (x \cdot x))) + (12 \cdot (y \cdot y)) \\
             & = ADD(ADD(MUL(8,MUL(MUL(x,x),MUL(y,y))),ADD(1,MUL(10,MUL(x,x)))),MUL(12,MUL(y,y)))
\end{align*}

Constraining all variables to edge labels we get the following circuit:

---

*NOTE*

The circuit shape is dependent on our choice of bracketing above.

---

#+BEGIN_SRC dot :file f_tiny_jj.png :exports results
digraph G2 {
        graph [forcelabels=true,
                nodesep=2.0,
                splines=ortho
        ];
        n1	[label=x,
                shape=box];
        n4	[label="*"];
        n1 -> n4	[xlabel=I_1];
        n1 -> n4;
        n8	[label="*"];
        n4 -> n8	[labeldistance=2,
                taillabel=W_3];
        n10	[label="*"];
        n4 -> n10	[labeldistance=4,
                taillabel=W_3];
        n2	[label=y,
                shape=box];
        n5	[label="*"];
        n2 -> n5	[xlabel=I_2];
        n2 -> n5;
        n5 -> n10	[xlabel=W_4];
        n13	[label="*"];
        n5 -> n13	[xlabel=W_4];
        n3	[label=10,
                shape=box];
        n3 -> n8;
        n11	[label="+"];
        n8 -> n11;
        n12	[label="*"];
        n10 -> n12	[labeldistance=4,
                taillabel=W_5];
        n15	[label="+"];
        n13 -> n15;
        n6	[label=12,
                shape=box];
        n6 -> n13;
        n7	[label=1,
                shape=box];
        n7 -> n11;
        n14	[label="+"];
        n11 -> n14;
        n9	[label=8,
                shape=box];
        n9 -> n12;
        n12 -> n14;
        n14 -> n15;
        n16	[label="0",
                shape=box];
        n15 -> n16	[label=" 0",
                labeldistance=2];
}
#+END_SRC

#+RESULTS:
[[file:f_tiny_jj.png]]

The circuit defines the inputs to be instances, while all other labels represent witnesses.
It also constrain the output to be zero.

* Circuit Execution
** Example: Executing Tiny-jubjub circuit $C_{tiny-jj}(\mathbb{F}_{13})$
We know from [[*Example: Tiny-jubjub membership (Example 125 MoonMath)][Tiny-jubjub circuit]] that any valid assignment with $S1 = x, S2 = y and S6 = 0$ means that $(x,y)$ is a point on the Tiny-jubjub curve.

From [[*Example: Tiny-jubjub Membership (Example 116 MoonMath)][Tiny-jubjub Membership Language]] we know that for example that $(11,6)$ is a vaid point on the curve.
Executing the circuit we get the assignments:

$S_{tiny\-jj}=<S_1,S_2,S_3,S_4,S_5>=<11, 6, 4, 10, 1>$

#+BEGIN_SRC dot :file c_tiny-jj.png :exports results
digraph G2C {
        graph [forcelabels=true,
                nodesep=2.0,
                splines=ortho
        ];
        n1	[label=x,
                shape=box];
        n4	[label="*"];
        n1 -> n4	[label="S_1=11",
                labeldistance=4];
        n1 -> n4;
        n8	[label="*"];
        n4 -> n8	[taillabel="S_3=4 "];
        n10	[label="*"];
        n4 -> n10	[labeldistance=4,
                taillabel="S_3=4"];
        n2	[label=y,
                shape=box];
        n5	[label="*"];
        n2 -> n5	[label="S_2=6"];
        n2 -> n5;
        n5 -> n10	[xlabel="S_4=10 "];
        n13	[label="*"];
        n5 -> n13	[headlabel="S_4=10",
                labeldistance=4];
        n3	[label=10,
                shape=box];
        n3 -> n8;
        n11	[label="+"];
        n8 -> n11	[headlabel="[10*4=1] "];
        n12	[label="*"];
        n10 -> n12	[taillabel="S_5=1 "];
        n15	[label="+"];
        n13 -> n15	[headlabel=" [10*12=3]"];
        n6	[label=12,
                shape=box];
        n6 -> n13;
        n7	[label=1,
                shape=box];
        n7 -> n11;
        n14	[label="+"];
        n11 -> n14	[headlabel="[1+1=2] "];
        n9	[label=8,
                shape=box];
        n9 -> n12;
        n12 -> n14	[label=" [8*1=8]"];
        n14 -> n15	[taillabel=" [2+8=10]"];
        n16	[label=0,
                shape=box];
        n15 -> n16	[label=" S_6=0",
                labeldistance=2];
}
#+END_SRC

#+RESULTS:
[[file:c_tiny-jj.png]]

* IN-PROGRESS Circuit satisfiability

Algebraic circuits give rise to [[*Formal Languages][Formal Languages]].
Every algebraic circuit $\mathbf{C}(\mathbb{F})$ over a field $\mathbb{F}$ defines a decision function over the alphabet $\Sigma_{I} \times \Sigma_{W} = F \times F$:

$R_{\mathbf{C}(\mathbb{F})}: \mathbb{F}^{*} \times \mathbb{F}^{*} \rightarrow \{true,false \};$
$(I,W) \mapsto \begin{cases}
\text{True} & \text{if } (I;W) \text{ is a valid assignment to  } \mathbf{C}(\mathbb{F})}, \\
\text{False} & \text{else.}
\end{cases}$

where:
+ The grammar of this language is encoded in the shape of the circuit.
+ Words are assignments to edge labels that are derived from circuit execution.
+ Statements are knowledge claims "Given instance $$I, there is a witness $W$ such that $(I;W)$ is a valid assignment to the circuit".

A constructive *proof* to this claim is therefore an assignment of a field element to every witness variable, which is *verified* by executing the circuit to see if the assignment of the execution meets the assignment of the proof.

** TODO Exercise: Tiny-jubjub membership (Exercise 101 MoonMath)
Consider the circuit $C_{tiny-jj}(\mathbb{F}_{13})$ from [[*Example: Tiny-jubjub membership (Example 125 MoonMath)][Tiny-jubjub membership]], with its associated language $L_{tiny-jj}$.
Construct a proof $\Pi$ for the instance $<11,6>$ and verify the proof.

To construct a proof for a statement "there exists a witness W such that (I1,I2,W) is a word in $L_{tiny-jj}$" we need to find input values for $W=(W_2,W_3,W_4,W_5)$

From [[*Example: Executing Tiny-jubjub circuit $C_{tiny-jj}(\mathbb{F}_{13})$][Executing Tiny-jubjub circuit]] we know that $(I_1, I_2, W_3, W_4, W_5>=<11, 6, 4, 10, 1>$ is a valid assignment.

Prover then executes the circuit with instance $I_1=11,I_2=6$ and inputs $W$ to decide whether the proof is a valid assignment or not:

# TODO: properly execute the graph in Rust

#+BEGIN_SRC sage :session . :exports both
F=GF(13)
I1,I2,W3,W4,W5,W6 = (F(11), F(6), F(4), F(10), F(1), F(0));

I1*I1 == W3
I2*I2 == W4
1+8*W3*W4+10*W3+12*W4 == W6
#+END_SRC

#+RESULTS:
: True
: True
: True

* TODO Groth16
* TODO PLONK
- [ ] https://www.cryptologie.net/article/527/understanding-plonk/
