#+STARTUP: overview
#+latex_class_options: [14pt]

* IN-PROGRESS Statements
** DONE Formal Languages

=General definition: Language=

Let $\Sigma$ be any set. Let $\Sigma^{*}$ be the set of all strings of a finite length $<x_1, \ldots,x_n>$ of elements $x_j \in \Sigma$, including the empty string $<> \in \Sigma^{*}$.
The *language* $L$ is a subset of the set of all finite strings $\Sigma^{*}$.
In this context:
- The set $\Sigma$ is called the *alphabet* of the language *L*.
- Elements from $\Sigma$ are called letters.
- Elements from $L$ are called *words*.
- If there are rules that specify which strings from $\Sigma^{*}$ belong to the language, these rules are called the *grammar* of the language.

** DONE Decision functions

*Decison function* $R$:

$R: \hspace{.5em} \Sigma^{*} \rightarrow \{ true, false \}$

decides whether a given string $x \in \Sigma^{*}$ is an element of the language or not.
The associated language can be written as the set off all strings decided by $R$:

$L_R:=\{ x \in \Sigma^{*} \hspace{.5em} | \hspace{.5em} R(x) = true \}$

=Definiton: statement=

*Statement* $S$ is the claim that language $L$ contains a word $x$.
A *proof* for statement $S$ is given by some string $P \in \Sigma^{*}$.
Such proof is *verified* by checking if:

$R(P)=true$

In this case $P$ is called an *instance* of the statement $S$.
** DONE Example: The empty language (Example 114 MoonMath)
Consider the alphabet $\Sigma=\mathbb{Z}_6$ , where $\mathbb{Z}_6$ is the ring of modular 6 arithmetic as derived in [[file:arithmetics.org::*Example 11 MoonMath (Arithmetic modulo $6$)][Arithmetic modulo $6$]].

- *Alphabet*: $\Sigma = \mathbb{Z}_6 = \{ 0, 1, 2, 3, 4, 5 \}$.
- *Language*: $L = \{ x \in (\mathbb{Z}_6)^* \mid x \times x \equiv 2 \pmod{6} \}$
  - where $x$ is a single element in $\mathbb{Z}_6$
- *Decision Function*:
$R(x) =  \begin{cases}
\text{True} & \text{if } x \times x \equiv 2 \pmod{6}, \\
\text{False} & \text{otherwise.}
\end{cases}$

Since $0^=0, 1^2=1, 2^2=4, 3^2=3, 4^2=4, 5^2=1$ no element has it's square equa to 2 (mod 6), the language is empty.

#+BEGIN_SRC sage :session . :exports both
Z6 = Integers(6)

def R(x):
    """
    Decision function for whether x * x \\equiv 2 mod 6.
    """
    return Z6(x)^2 == Z6(2)

for x in range(6):
    print(f"R({x}) = {R(x)}")
#+END_SRC

#+RESULTS:
: R(0) = False
: R(1) = False
: R(2) = False
: R(3) = False
: R(4) = False
: R(5) = False

** DONE Example: 3-Factorization (Example 115 MoonMath)
/Language which consists of those elements of the field $F_13$ that can be factored into 3 other elements./

Formalizing the description:
- *Alphabet*: $\Sigma = F_{13}$.
- *Language*: $L_{3,fac} = \{ x_1, x_2, x_3, x_4 \in F_{13}: \hspace{.5em} x_4 = x_1 \cdot x_2 \cdot x_3 \}$.
- *Decision Function*:
$R(<x_1,x_2,x_3,x_4>) =  \begin{cases}
\text{True} & \text{if } x_4 = x_1 \cdot x_2 \cdot x_3 \\
\text{False} & \text{otherwise.}
\end{cases}$,

where:
- $x_1, x_2, x_3, x_4 \in F_{13}$

The string $<2, 12, 4, 5>$ is a constructive proof for the statement that L_{13,fac} contains words:

#+BEGIN_SRC sage :session . :exports both
F13 = GF(13)

def R(x1,x2,x3,x4):
    return F13(x4) == F13(x1)*F13(x2)*F13(x3)

x1=2; x2=12; x3=4; x4=5

# verification of the proof
print(f"R{x1,x2,x3,x4} = {R(x1,x2,x3,x4)}")
#+END_SRC

#+RESULTS:
: R(2, 12, 4, 5) = True
** IN-PROGRESS Example: Tiny-jubjub Membership (Example 116 MoonMath)
/Language where word are points on the Tiny-jubjub curve (in it's Twisted Edwards form)./

Formalizing the description:
- *Alphabet*: $\Sigma = F_{13}$.
- *Decision Function*:
$R(x_1,x_2) =  \begin{cases}
\text{True} & \text{if } 3 \cdot x_{1}^{2} + x_{2}^{2} = 1 + 8 \cdot x_{1}^{2} \cdot x_{2}^{2} \\
\text{False} & \text{otherwise.}
\end{cases}$
- *Language*:
$L = \{ x_1, x_2 \in F_{13} : \hspace{.5em} R(x_1,x_2) = true \}$

Any of the points on the curve is therefore a constructive proof that the there is a word in the language:

#+BEGIN_SRC sage :session . :exports both
F13 = GF(13)

L_ETJJ = []
for x in F13:
  for y in F13:
    if F13(3)*x^2 + y^2 == 1+ F13(8)*x^2*y^2:
      L_ETJJ.append((x,y))

ETJJ = Set(L_ETJJ)
ETJJ
#+END_SRC

#+RESULTS:
: {(0, 1), (8, 8), (11, 7), (1, 2), (2, 7), (1, 11), (6, 4), (7, 9), (10, 0), (12, 2), (12, 11), (7, 4), (5, 5), (5, 8), (3, 0), (11, 6), (0, 12), (2, 6), (6, 9), (8, 5)}

** TODO Instance and witness
* TODO Groth16
* TODO PLONK
