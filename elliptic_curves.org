#+STARTUP: overview
#+latex_class_options: [12pt]

* Contents
:PROPERTIES:
:VISIBILITY:  all
:TOC:      :include all :ignore this
:END:
:CONTENTS:
- [[#affine-short-weierstrass-form][Affine Short Weierstrass form]]
  - [[#example][Example]]
- [[#point-at-infinity][Point at infinity]]
- [[#ec-group-law][EC group law]]
  - [[#geometric-interpretation-elliptic-curve-point-addition-chord-rule][Geometric interpretation: Elliptic curve point addition (chord rule)]]
  - [[#geometric-interpretation-point-doubling-tangent-rule][Geometric interpretation: Point doubling (tangent rule)]]
  - [[#explicit-formulas-for-the-group-law][Explicit formulas for the group law]]
  - [[#deriving-group-law-for-ecs-example-211][Deriving group law for ECs: Example 2.1.1]]
  - [[#deriving-group-law-for-ecs-example-212][Deriving group law for ECs: Example 2.1.2]]
- [[#order-of-an-elliptic-curve][Order of an Elliptic Curve]]
- [[#hasses-theorem][Hasse's theorem]]
  - [[#example][Example]]
- [[#order-of-a-point-on-an-elliptic-curve][Order of a point on an elliptic curve]]
  - [[#example][Example]]
  - [[#example-finding-points-of-a-given-order][Example: finding points of a given order]]
- [[#subgroup-p-generated-by-a-point-p][Subgroup $<P>$ Generated by a Point P]]
  - [[#example][Example]]
- [[#lagranges-theorem-for-elliptic-curves][Lagrange's theorem for Elliptic Curves]]
  - [[#example-lagranges-theorem-for-ecs][Example: Lagrange's theorem for ECs]]
- [[#the-exponential-map][The exponential map]]
- [[#elliptic-curve-scalar-multiplication][Elliptic Curve scalar multiplication]]
- [[#projective-short-weierstrass-form][Projective Short Weierstrass form]]
  - [[#example][Example]]
- [[#elliptic-curve-discrete-logarithm-problem-ecdlp][Elliptic Curve Discrete Logarithm Problem (ECDLP)]]
  - [[#discrete-logarithm-problem-dlp][Discrete Logarithm Problem (DLP)]]
  - [[#elliptic-curve-discrete-logarithm-problem][Elliptic Curve Discrete Logarithm Problem]]
  - [[#example-1][Example 1]]
  - [[#example-222-pairings-for-beginners][Example 2.2.2 Pairings for beginners]]
- [[#elliptic-curves-over-prime-field-extensions][Elliptic Curves over prime field extensions]]
  - [[#prime-field-extensions][Prime field extensions]]
  - [[#example-extending-f_5-to-f_52][Example: Extending $F_5$ to $F_{5^2}$]]
  - [[#example-visualizing-the-extension][Example: Visualizing the extension]]
  - [[#example-constructing-the-extension-field-f_4f_22][Example: Constructing the extension field $F_4=F_{2^2}$]]
  - [[#example-constructing-the-extension-field-f_32][Example: Constructing the extension field $F_{3^2}$.]]
- [[#extending-elliptic-curves-to-prime-field-extensions][Extending Elliptic Curves to prime field extensions]]
  - [[#example][Example]]
- [[#field-extension-towers][Field extension towers]]
  - [[#example-extending-f_97-to-f_9712-using-a-tower-of-extensions][Example: extending $F_{97}$ to $F_{{97}^{12}}$ using a tower of extensions]]
  - [[#example-extending-f_3-to-f_36-using-a-tower-of-extensions][Example: extending $F_3$ to F_{3^6} using a tower of extensions]]
- [[#r-torsion-point][r-torsion point]]
- [[#r-torsion-group-ef_qr][r-torsion group $E(F_q)[r]$]]
  - [[#example][Example]]
- [[#embedding-degree][Embedding degree]]
  - [[#example][Example]]
- [[#r-torsion-group-ef_qkrr-the-full-r-torsion-group][r-torsion group $E(F_{q^{k(r)}})[r]$ (the "full" r-torsion group)]]
  - [[#example-91-moonmath-finding-full-r-torsion-group][Example 91 MoonMath: Finding full r-torsion group]]
  - [[#example-411-pairings-for-beginners-finding-full-r-torsion-group][Example 4.1.1 Pairings For Beginners: Finding full r-torsion group]]
  - [[#example-412-pairings-for-beginners][Example 4.1.2 Pairings For Beginners]]
- [[#ecdsa][ECDSA]]
  - [[#materials][materials]]
  - [[#notes][notes]]
- [[#additional-materials][Additional materials]]
:END:

* Affine Short Weierstrass form
An *Elliptic Curve* (using short Weierstrass form and affine coordinates) is an equation of the form:

$y^2=x^3+a \cdot x +b$

where:
- $a,b,x$ and $y$ are elements of some finite field.
- the so called discriminant $4a^3+27b^2$ is not equal to $0$ (ensures that the curve is non-singular aka the curve has no cusps or self-intersections).

Any $(x,y)$ satisfying the equation are points on the curve.

Thus Elliptic curve in affine space as a set of affine points together with the [[*Point at infinity][Point at infinity]]:

$E={(x,y) \in A^2(K) : y^2 = x^3 + ax +b} \hspace{.5em} \bigcup \hspace{.5em} {\mathcal{\{O\}}}$

** Example
We will define an EC over $F_{101}$ and set $a=0$.

#+BEGIN_SRC sage :session . :exports both
K = GF(101)
E = EllipticCurve(K,[0,0,0,0,3])
E
#+END_SRC

#+RESULTS:
: Elliptic Curve defined by y^2 = x^3 + 3 over Finite Field of size 101

* Point at infinity
- [ ] A question that may arise from this description is what happens if the line that is drawn between the two points does not intersect the curve again? In this case the line is said to intersect the curve at "infinity", and the result of the addition is the point
[[id:e7c740fb-6ec2-428b-9e47-2fa8ddd3a643][Point at infinity]]
* IN-PROGRESS EC group law
** DONE Geometric interpretation: Elliptic curve point addition (chord rule)
Over any field a line (a degree one equation in $x$ and $y$) intersects a cubic equation (a degree three equation in $x$ and $y$) in three places.
In other words if we run a line:

$\ell: \hspace{.5em} y = \lambda x + \upsilon$

between two points $P=(x_P, y_P)$ and $Q=(x_Q,y_Q)$ on E, then substitute this line into:

$E: \hspace{.5em} y^2=x^3+ax+b$

will give a cubic polynomial in $x$:

#+BEGIN_SRC maxima :exports both :results output replace
eq1: y^2 = x^3 + a * x + b;
eq2: y = lambda * x + v;
eq3: subst(eq2,eq1);

print(expand(eq3));
#+END_SRC

#+RESULTS:
:  2       2                   2    3
: x  lambda  + 2 v x lambda + v  = x  + a x + b

The roots of which are the x-coordinates of the three points of intersection between $\ell$ and $E$.

Knowing the two roots ($x_P$ and $x_Q$) allows us to determine a unique third root that corresponds to the third point in the (affine) intersection $\ell \cap E$, which we denote $\textcircled{-}R$.
This point is then flipped over the x-axis to the point $R=P {\footnotesize \textcircled{+}} Q$.
The inverse of any element $R = (x_R , y_R )$ is taken as $\textcircled{-} R = (x_{R}, - y_{R} )$

#+name: chord-line
#+begin_src maxima :results graphics file :file chord-line.png :exports results
programmode: false;
/*E(x) := if x < 0 then -1*sqrt(x^3 -2*x) else sqrt(x^3 -2*x);*/
E1(x) := 1*sqrt(x^3 -2*x);
E2(x) := -1*sqrt(x^3 -2*x);
l(x) := x;
plot2d([E1,E2, l], [x, -5, 5], [y,-5,5], [png_file, "./chord-line.png"]);
#+end_src

#+RESULTS: chord-line
[[file:chord-line.png]]

** DONE Geometric interpretation: Point doubling (tangent rule)
When computing $R = P \textcircled{\\+} P$ , the line $\ell$ is computed as the tangent to E at P.
That is, the derivatives of $\ell$ and E are matched at P, so (counting multiplicities) $\ell$ intersects E twice at P.

#+begin_src maxima :results graphics file :file tangent-line.png :exports results
programmode: false;
/*E(x) := if x < 0 then -1*sqrt(x^3 -2*x) else sqrt(x^3 -2*x);*/
E1(x) := 1*sqrt(x^3 -2*x);
E2(x) := -1*sqrt(x^3 -2*x);
l(x) := -x/2-3/2;
plot2d([E1,E2, l], [x, -5, 5], [y,-5,5], [png_file, "./tangent-line.png"]);
#+end_src

#+RESULTS:
[[file:tangent-line.png]]

** IN-PROGRESS Explicit formulas for the group law

=Point doubling: [2]P=P+P=
The formula for doubling a point $P=(x_1,y_1)$ on $E: y^2=x^3+Ax+B$ is:

$2[P]=(x_3,y_3)$

where:

$x_3=m^2 - 2x_1$
$y_3=m \cdot (x_1-x_3) - y_1$

For $m=(\frac{3x_{1}^{2}+A}{2y_1})$ (the slope of the tangent line).

=Point inversion=
For $P=(x,y),\quad -P=(x,-y)$

=TODO Point addition: P+Q=S=

** DONE Deriving group law for ECs: Example 2.1.1

$E/\mathbb{R}: y^2=x^3-2x$

---

*NOTE*: finding $\ell$ for the chord rule

$\ell$ is a line that passes through $P=(x_1,y_1)$ and $Q=(x_2,y_2)$.
For example for P=(-1,-1) and Q=(0,0):

#+BEGIN_SRC maxima :exports both :results output replace
print(solve([-1=a*(-1)+b, 0=a*0+b], [a,b]));
#+END_SRC

#+RESULTS:
: [[a = 1, b = 0]]

Hence $\ell: y=x$

---

Points $(-1,-1)$, $(0,0)$ and $(2,2)$ are all on $E$ and also on the line $\ell$, therefore we use the [[*Geometric interpretation: Point addition (chord rule)][chord rule]]:

#+BEGIN_SRC maxima :exports both :results output replace
eq1: y^2=x^3-2*x;
eq2: y=x;
eq3: subst(eq2,eq1);

print(eq3);

print(allroots(eq3));
#+END_SRC

#+RESULTS:
:  2    3
: x  = x  - 2 x
: [x = 0.0, x = - 1.0, x = 2.0]

- Compute $(-1,-1) \textcircled{\\+} (0,0)$.

#+BEGIN_SRC maxima :exports both :results output replace
print(solve([y=x, y^2=x^3-2*x, x=2], [x,y]));
#+END_SRC

#+RESULTS:
: [[x = 2, y = 2]]

Flipping this over the x-axis we get $(2,-2)$

- Compute $(2,2) \textcircled{\\+} (0,0)$.

#+BEGIN_SRC maxima :exports both :results output replace
print(solve([y=x, y^2=x^3-2*x, x=-1], [x,y]));
#+END_SRC

#+RESULTS:
: [[x = - 1, y = - 1]]

Flipping this over the x-axis we get $(-1,1)$

- Compute $(-1,-1) \textcircled{\\+} (2,2)$.

#+BEGIN_SRC maxima :exports both :results output replace
print(solve([y=x, y^2=x^3-2*x, x=0], [x,y]));
#+END_SRC

#+RESULTS:
: [[x = 0, y = 0]]
Flipping this over the x-axis we get $(0,0)$
- Compute $[2](-1,-1)=(-1,-1) \textcircled{\\+} (-1,-1)$ (point doubling the "tangent rule")

To use the "tangent rule", we need to find the line tangent to E at (-1,-1).
We start by differentiating both sides of $y^2=x^3-2x$ with respect to x:

$y^2=x^3-2x \hspace{1em} |  \hspace{.5em} \frac{d}{dx}$

We want to find \frac{dy}{dx}.

- *left hand side.*

Here $y$ is a function of x (meaning $y=y(x)$).

$\frac{d}{dx}(y^2)=\frac{d}{dx}(y(x)^{2})$

$y=u^2, \hspace{1em} u=y(x)$

Using the [[file:arithmetics.org::*Chain rule differentiation][Chain rule]]:

$\frac{dy}{dx}=\frac{dy}{du} \cdot \frac{du}{dx}$

$\frac{d}{du}(u^2) \cdot \frac{d}{dx}(y(x))$

$2u \cdot \frac{d}{dx}(y(x))$

$2y(x) \cdot \frac{d(y(x))}{dx}$


$2y \cdot \frac{dy}{dx}$

- *right hand side.*

Straightforward differentiation:

$\frac{d}{dx}(x^3-2x)=3x^2-2$

Combining the results we get:

$2y\frac{dy}{dx}=3x^2-2$

Solving for $\frac{dy}{dx}$:

$\frac{dy}{dx}=\frac{3x^2-2}{2y}$

Evaluating at (-1,1):

$\frac{dy}{dx}=\frac{3(-1)^2-2}{2(-1)}=-\frac{1}{2}$

The slope $m$ of the tangent line is $-\frac{1}{2}$.

Using the point-slope form of the line:

$y - y_{1} = m(x - x_1)$

where $m=-\frac{1}{2}, \hspace{.5em} (x_1,y_1)=(-1,-1)$ we get:

$y-(-1)=-\frac{1}{2}(x-(-1))$

*Final answer*: The equation of the tangent line to the elliptic curve E: y^2=x^3-2x at (-1,1) is:

$\ell: y=-\frac{1}{2}x-\frac{3}{2}$

It intersects the curve $E$ once more:

#+BEGIN_SRC maxima :exports both :results output replace
print(solve([y=-(x+3)/2, y^2=x^3-2*x], [x,y]));
#+END_SRC

#+RESULTS:
:                           9        21
: [[x = - 1, y = - 1], [x = -, y = - --]]
:                           4        8

which gives:

$(-1,-1) \textcircled{\\+} (-1,-1) = (\frac{9}{4},-\frac{21}{8})$

$\square$

** DONE Deriving group law for ECs: Example 2.1.2
Same curve equation but over a finite field

$E(F_{23}): y^2=x^3-2x$

Find $(5,7) \textcircled{\\+} (8,10)$

1) Line that joins them is:

#+BEGIN_SRC maxima :exports both :results output replace
print(solve([7=a*5+b, 10=a*8+b], [a,b]));
#+END_SRC

#+RESULTS:
: [[a = 1, b = 2]]

$y=x+2$

Third point of intersection with E is:

#+BEGIN_SRC maxima :exports both :results output replace
print(solve([y=x+2, y^2=x^3-2*x], [x,y]));
#+END_SRC

#+RESULTS:
: [[x = - 1, y = 1], [x = 1 - sqrt(5), y = 3 - sqrt(5)],
:                                            [x = sqrt(5) + 1, y = sqrt(5) + 3]]

#+BEGIN_SRC sage :session . :exports both
F = GF(11)
E = EllipticCurve(F, [-2,0])
E

F(-2)
E(-1,1)
E(-1,-1)
#+END_SRC

#+RESULTS:
: Elliptic Curve defined by y^2 = x^3 + 9*x over Finite Field of size 11
: 9
: (10 : 1 : 1)
: (10 : 10 : 1)

Third point of intersection is S=(10,1)=(-1,1). Negating the y-coordinate gives it's inverse and we get $(5,7) \textcircled{\\+} (8,10) = (10,10)$

* Order of an Elliptic Curve
The order of an elliptic curve is the number $n$ of points on it (including the [[*Point at infinity][Point at infinity]]).

---
*NOTE*
The order of an elliptic curve over finite field need not be equal to the order of the field!

[[*Hasse's theorem][Hasse's theorem]] on elliptic curves, also referred to as the *Hasse bound*, provides an estimate of the number of points on an elliptic curve over a finite field, bounding the value both above and below.

---

* IN-PROGRESS Hasse's theorem
If N is the number of points on the elliptic curve E over a finite field with q elements, then Hasse's result states that:

${\displaystyle |N-(q+1)|\leq 2{\sqrt {q}}.}$
** TODO Example
* Order of a point on an elliptic curve
The *order of a point on an elliptic curve* is the smallest positive integer n such that

$[n]P=\mathcal{O}$

where:

- $P$ is a point on the elliptic curve,
- $[n]P$ denotes the point $P$ added to itself $n$ times,
- $\mathcal{O}$ is the identity element (the [[*Point at infinity][Point at infinity]]).

** Example
#+BEGIN_SRC sage :session . :exports both
F5=GF(5)
E_F5=EllipticCurve(F5, [0,0,0,1,1])

P=E_F5(0,1,1)
1*P
2*P
3*P
4*P
5*P
# ...
# equal point at infinity
9*P
# hence order of P is 9
P.order()
#+END_SRC

#+RESULTS:
: (0 : 1 : 1)
: (4 : 2 : 1)
: (2 : 1 : 1)
: (3 : 4 : 1)
: (3 : 1 : 1)
: (0 : 1 : 0)
: 9

---
*NOTES*

- The size of the finite field $F_q$ is q, but the order of the elliptic curve group $\#E(F_q)$ can be much larger than $q$. This means that the order of a point can also be larger than $q$
- The order of a point $P$ on the elliptic curve must divide the order of the EC group  $\#E(F_q)$. Thus, the maximum possible order of any point on the elliptic curve is $\#E(F_q)$.
---

** Example: finding points of a given order

Example below illustrates that there can be multiple points of a given order

#+BEGIN_SRC sage :session . :exports both
F5=GF(5)
E_F5=EllipticCurve(F5, [1,1])

# find all generators (of the full EC group)
generators = []
for P in E_F5.points():
    if P.order() == E_F5.order():
        generators.append(P)

# find all points of given order
E_order = E_F5.order()
for k in range(1,10):
  for P in generators:
    if Integer(k).divides(E_order):
      print("k: ", k, (E_order/k) * P)
#+END_SRC

#+RESULTS:
#+begin_example
k:  1 (0 : 1 : 0)
k:  1 (0 : 1 : 0)
k:  1 (0 : 1 : 0)
k:  1 (0 : 1 : 0)
k:  1 (0 : 1 : 0)
k:  1 (0 : 1 : 0)
k:  3 (2 : 1 : 1)
k:  3 (2 : 4 : 1)
k:  3 (2 : 4 : 1)
k:  3 (2 : 1 : 1)
k:  3 (2 : 4 : 1)
k:  3 (2 : 1 : 1)
k:  9 (0 : 1 : 1)
k:  9 (0 : 4 : 1)
k:  9 (3 : 1 : 1)
k:  9 (3 : 4 : 1)
k:  9 (4 : 2 : 1)
k:  9 (4 : 3 : 1)
#+end_example

* DONE Subgroup $<P>$ Generated by a Point P
1. Group structure
   - For an elliptic curve $E$ defined over a finite field $F_p$ the set of points on the curve, including the point at infinity $\mathcal{O}$ forms a *finite abelian group* under the point addition operation.
   - The order of that group is $r=|E|$, the total number of points on the curve (including the point at infinity $\mathcal{O}$).
2. Order of a point (see also [[OrderOfAPoint][Order of a point...]])
   - Every point $P$ on the EC generates a cyclic subgroup denoted $<P>$.
   - Order of a point is the smallest $k > 0$ such that $k\cdot P = \mathcal{O}$ (where $\mathcal{O}$, the point at infinity, is the group's identity element).
   - Order of a point P $k$ is therefore the size of the cyclic subgroup generated by $P$.

---

*NOTE*

Assume $E$ is finite and cyclic.
Not every point $P$ generates the whole group $E$: only the points with order $k=r$ do.

For example for $E$ with order 6 and a generator $G$ the group is:

$E = \{ \mathcal{O}, G, 2G, 3G, 4G, 5G \}$

their orders are:
- For $G$ $k=6$ since $6 \cdot G=\mathcal{O}$
- For $2G$ $k=3$ since $3 \cdot 2G=\mathcal{O}$
- For $3G$ $k=2$ since $2 \cdot 3G=\mathcal{O}$
- For $4G$ $k=3$ since $3*4G=12 \hspace{.5em} \text{mod} \hspace{.5em} 6 \cdot G= \mathcal{O}$
- For $5G$ $k=6 since $6*5G=30 \hspace{.5em} \text{mod} \hspace{.5em} 6 \cdot G= \mathcal{O}$

Hence only $G$ and $5G$ are the entire groups generators.

---

** Example
<P> is subgroup of order 17, 17*P=inf

#+BEGIN_SRC sage :session . :exports both
q=101
F = GF(q)
E = EllipticCurve(F,[0,0,0,0,3])
E

P = E(1,2)
for i in range(1,18):
    print(i,"* P =" , i*P)

# it is NOT the entire group generator
P.order() == E.order()
#+END_SRC

#+RESULTS:
#+begin_example
Elliptic Curve defined by y^2 = x^3 + 3 over Finite Field of size 101
1 * P = (1 : 2 : 1)
2 * P = (68 : 74 : 1)
3 * P = (26 : 45 : 1)
4 * P = (65 : 98 : 1)
5 * P = (12 : 32 : 1)
6 * P = (32 : 42 : 1)
7 * P = (91 : 35 : 1)
8 * P = (18 : 49 : 1)
9 * P = (18 : 52 : 1)
10 * P = (91 : 66 : 1)
11 * P = (32 : 59 : 1)
12 * P = (12 : 69 : 1)
13 * P = (65 : 3 : 1)
14 * P = (26 : 56 : 1)
15 * P = (68 : 27 : 1)
16 * P = (1 : 99 : 1)
17 * P = (0 : 1 : 0)
False
#+end_example

* Lagrange's theorem for Elliptic Curves
:PROPERTIES:
:ID:       2a523cd8-b0c4-481c-92b4-cddc426df3c2
:END:

- See also [[id:874070dc-6425-409d-9f1d-c5dc791c0196][Basic Lagrange's theorem]]

=Theorem=

If $P$ is a point on the curve $E$ then the order of $P$ $k$ divides the order of the curve:

 $r=|E|$: $k \hspace{.5em} \text{divides} \hspace{.5em}  r$.

Implications for Scalar Multiplication on the EC:
- For any point $P$ on $E$ $r\cdot P = \frac{r}{k} k \cdot P = \mathcal{O}$.
- this is becasue $r$ is the groups order and multiplying any group element by the order yields the identity element.
- scalar multiplication is periodic with period $r$: $n\cdot P = (n \hspace{.5em} \text{mod} \hspace{.5em} r) \cdot P$

** Example: Lagrange's theorem for ECs
#+BEGIN_SRC sage :session . :exports both
q=5
Fq=GF(q)
E=EllipticCurve(Fq,[1,1])

r = E.order()
P = E.random_point()
k = P.order()

print(f"kP: {k} * {P} = {k*P}")
print(f"rP: {r} * {P} = {k*P}")
print(f"r | k: {r.divides(k)}")

(r+1)*P
((r+1)%r) *P
#+END_SRC

#+RESULTS:
: kP: 9 * (4 : 3 : 1) = (0 : 1 : 0)
: rP: 9 * (4 : 3 : 1) = (0 : 1 : 0)
: r | k: True
: (4 : 3 : 1)
: (4 : 3 : 1)
* TODO The exponential map
- p39
* Elliptic Curve scalar multiplication
Let $F$ be a finite field, $E(F)$ an elliptic curve of order $n$ and $P$ a generator of $E(F)$.
Then the elliptic curve scalar multiplication with base $P$ is defined as follows:

$[\cdot]P: Z_n \rightarrow E(F): m \mapsto [m]P$

where:
$[0]P=\mathcal{O}$ and $[m]P=P+P+...+P$ is the $m$-fold sum of $P$ with itself.

Therefore, elliptic curve scalar multiplication is an instantiation of the general [[*The exponential map][exponential map]] using additive instead of multiplicative notation.
* Projective Short Weierstrass form
---

*NOTE: Notation*

$A^n(K)$ : affine $n$-space over the field $K$

---

Instead of working with points in $n$-space, we now work with lines that pass through the origin in $(n+1)$-space.

This means affine points (see [[*Affine Short Weierstrass form][Affine Short Weierstrass form]]) in 2-space becomes lines in the $3$-space, namely that:

$(x,y) \in A^2(\bar{K})$ corresponds to the line defined by all points of the form:

$(\lambda x, \lambda y, \lambda) \in P^2(\bar{K})$,

where:
- $\lambda \in \bar{K}^{*}$.

That is, $P^2$ is $A^3 /\ \{(0, 0, 0)\}$ modulo the following congruence condition:

$(x_1, y_1, z_1 ) \sim (x_2, y_2, z_2)$

if there exists $\lambda \in \bar{K}^{*}$ such that $(x_1, y_1, z_1) = (\lambda x_2 , \lambda y_2, \lambda z_2)$.

There are many copies of $A^2$ in $P^2$ , but traditionally we map the affine point $(x, y) \in A^2$ to projective space via the trivial inclusion:

$(x, y) \rightarrow (x : y : 1)$,

and for any $(X : Y : Z) \neq \mathcal{O} \in P^2$ , we map back to $A^2$ via $(X : Y : Z ) \rightarrow  (X / Z, Y / Z)$.

The point at infinity $\mathcal{O}$ is represented by $(0 : 1 : 0)$ in the projective space.

The way we define the collection of points in projective space is to homogenise $E : y^2 = x^3 + a \cdot x + b$ by making the substitution $x = X / Z$ and $y = Y / Z$, and multiplying by $Z^3$ to clear the denominators, which gives the *projective Short Weierstrass form* of an elliptic curve:

$E_P = \{ [X : Y : Z] \in P \hspace{.5em} | \hspace{.5em} Y^2 \cdot Z = X^3 + a \cdot X \cdot Z^2 + b \cdot Z^3 \}$

** Example
#+BEGIN_SRC sage :session . :exports both
F13 = GF(13)
E_F13 = EllipticCurve(F13, [F13(0), F13(5)])
E_F13
E_F13.order()

# there are 16 classes (X : Y : Z) \in P^2(F_13)
for p in E_F13:
    print(p)
#+END_SRC

#+RESULTS:
#+begin_example
Elliptic Curve defined by y^2 = x^3 + 5 over Finite Field of size 13
16
(0 : 1 : 0)
(2 : 0 : 1)
(4 : 2 : 1)
(4 : 11 : 1)
(5 : 0 : 1)
(6 : 0 : 1)
(7 : 6 : 1)
(7 : 7 : 1)
(8 : 6 : 1)
(8 : 7 : 1)
(10 : 2 : 1)
(10 : 11 : 1)
(11 : 6 : 1)
(11 : 7 : 1)
(12 : 2 : 1)
(12 : 11 : 1)
#+end_example

The substitutions from the example above (x = X/Z, y = Y/Z) are the most simple (and standard) way to obtain projective coordinates, but we are not restricted to this choice of substitution.

* Elliptic Curve Discrete Logarithm Problem (ECDLP)
** Discrete Logarithm Problem (DLP)
=Definition=

Let $G$ be a finite cyclic group of order $r$ and let $g$ be a generator of $G$.

There exists an exponential map:
$g^{(\cdot)}: Z_r \rightarrow G; x \mapsto g^x$

that maps the residue classes from modulo $r$ arithmetic onto the group in 1:1 correspondence.
The DLP is the task of finding an inverse to this map, that is a solution $x \in Z_r$ to the following equation for some given $h,g\in G$:

\begin{equation*}
h=g^x
\end{equation*}

There are groups in which the DLP is assumed infisible to solve and they are called *DL-secure* groups.

=Example=

If the group is $Z_{5}^{*}$, and the generator is 2, then the discrete logarithm of 1 to the base 2 is 4 because $2^4 \equiv 1 \medspace \text{mod} \medspace 5$.

** Elliptic Curve Discrete Logarithm Problem
Extending [[*Discrete Logarithm Problem (DLP)][Discrete Logarithm Problem (DLP)]], a DLP can be constructed with elliptic curves.

By selecting a point on an elliptic curve group, one can double it to obtain the point 2P.
After that, one can add the point P to the point 2P to obtain the point 3P.
The determination of a point $nP$ in this manner is referred to as Scalar Multiplication of a point (see [[*Elliptic Curve scalar multiplication][Elliptic Curve scalar multiplication]]).

=Definition: Elliptic Curve Discrete Logarithm Problem=
Given points $P$ and $Q$ in the group, find a number $k$ such that $Pk = Q$

** Example 1
Consider $y^2 = x^3 + 9x + 17$ over $F_{23}$.
What is the discrete logarithm $k$ of $Q = (4,5)$ to the base $P = (16,5)$?
Brute-force way to find $k$ is to compute scalar multiples of $P$ until $Q$ is found:

#+BEGIN_SRC sage :session . :exports both
G = GF(23)
E = EllipticCurve(G,[0,0,0,9,17])
P = E(16,5)
Q = E(4,5)
for k in range(1,20):
  if ((k * P) == Q): print(k)
#+END_SRC

#+RESULTS:
: 9

---
*NOTE*

See also this visualization:
https://andrea.corbellini.name/ecc/interactive/modk-mul.html

---

** Example 2.2.2 Pairings for beginners
Suppose we are presented with an instance of the ECDLP: we are given $Q = (612, 827)$, and we seek to find $k$ such that $[k]P = Q$
Instead of a brute-force attack we can map the instance into each prime order subgroup by multiplying by the appropriate cofactor, and then solve for $k_j \equiv k \pmod{j}, j \in \{2, 3, 7, 23\}$.

#+BEGIN_SRC sage :session . :exports both
F1021 = GF(1021)
E_F1021 = EllipticCurve(F1021, [905, 100])
E_F1021

E_order = E_F1021.order()
E_order
E_order.factor()

#P=E_F1021.gens()[0]
P=E_F1021(1006,416)
P.order()
Q=E_F1021(612,827)

# j = 2
P_j = (E_order / 2) * P
Q_j = (E_order / 2) * Q
for k in range(0,2):
  if ((k * P_j) == Q_j): print(k)

# j = 3
P_j = (E_order / 3) * P
Q_j = (E_order / 3) * Q
for k in range(0,3):
  if ((k * P_j) == Q_j): print(k)

# j = 7
P_j = (E_order / 7) * P
Q_j = (E_order / 7) * Q
for k in range(0,7):
  if ((k * P_j) == Q_j): print(k)

# j = 23
P_j = (E_order / 23) * P
Q_j = (E_order / 23) * Q
for k in range(0,23):
  if ((k * P_j) == Q_j): print(k)

# Now, we can use the Chinese Remainder Theorem to solve
# k = 1 mod 2
# k = 0 mod 3
# k = 1 mod 7
# k = 20 mod 23
k = CRT([1, 0, 1, 20], [2, 3, 7, 23])
k

# which solves original DLP problem:
k * P == Q
#+END_SRC

#+RESULTS:
#+begin_example
Elliptic Curve defined by y^2 = x^3 + 905*x + 100 over Finite Field of size 1021
966
2 * 3 * 7 * 23
966
1
0
1
20
687
True
#+end_example

* IN-PROGRESS Elliptic Curves over prime field extensions
** Prime field extensions
---
*NOTES*

- $F_p[x]$ is a ring of polynomials with coefficients in $F_p$.
- An [[file:algebra.org::*Irreducible polynomial][Irreducible polynomial]] is a polynomial that cannot be factored into the product of two non-constant polynomials.

---

Given some prime $p \in P$ a natural number $m \in N$ and an irreducible polynomial $P \in F_p[x]$
of degree $m$ with coefficients from the prime field $F_p$ a prime field extension $(F_{p^m}, +, \cdot)$ is defined as follows:

- The set $F_{p^m}$ of the prime field extension is given by the set of all polynomials with degree less than $m$:

$F_{p^m} := \{ a_{m-1}x^{m-1} + a_{m-2} x^{m-2} + \ldots + a_1 x + a_0 \hspace{.5em} | \hspace{.5em} a_i \in F_p \}$

- The addition law $+$ is given by the addition of polynomials.
- The multiplication $\cdot$ law of the prime field extension is given by first multiplying the two polynomials, then dividing the result by the irreducible polynomial P and keeping the remainder.
- The neutral element of the additive group  $(F_{p^m}, +)$ is the zero polynomial $0$.
- The neutral element of the multiplicative group  $(F_{p^m}^{*}, \cdot)$ is the unit polynomial $1$.
- The multiplicative inverse can be computed by the Extended Euclidean Algorithm

---

*NOTE*

- $F_{p^m}$ is of characteristic $p$, since the multiplicative neutral element $1$ is equivalent to the multiplicative element 1 from the underlying prime field, and hence $\sum_{j=0}^{p} 1=0$.
- $F_{p^m}$ is finite and contains $p^m$ many elements, since elements are polynomials of degree $<m$, and every coefficient $a_j$ can have $p$ many different values.
- It can be shown that $F_{p^m}$ is the set of all remainders when dividing *all* polynomials $Q \in F_p[x]$ by an irreducible polynomial $P$ of degree $m$. This is analogous to how $F_p$ is the set of all remainders when dividing integers by $p$.

---
** DONE Example: Extending $F_5$ to $F_{5^2}$
Steps to Construct $\mathbb{F}_{5^2}$:

*Step 1*: /Choose an Irreducible Polynomial/
- Find an irreducible polynomial of degree 2 over $\mathbb{F}_{5}$. For example, $f(x) = x^2 + 2$.
- $f(x)$ is such that it's root is $\alpha$ in the extension field $\mathbb{F}_{5^2}$:

$f(\alpha) = \alpha^2 + 2 = 0 \quad (\text{in} \quad  \mathbb{F}_{11^2})$

*Step 2*: /Construct the Field/
- The extension field $\mathbb{F}_{5^2}$ consists of all polynomials with coefficients in $\mathbb{F}_{5}$, modulo $f(x)$.
- Elements of the extension field are congruence classes of polynomials with degrees less than $f(x)$. This is similar to how numbers in modular arithmetic are representatives from $0$ to $n - 1$ for $\text{mod} \hspace{.5em} n$.
- Therefore, elements of $\mathbb{F}_{5^2}$ can be expressed as $a_1x + a_0$, where $a_1, a_0 \in \mathbb{F}_{5}$.
- $F_5^2=F_5(\alpha)$ with $\alpha^2+2=0$

*Step 3*: Arithmetic in $\mathbb{F}_{5^2}$
- Addition and subtraction are performed by adding or subtracting corresponding coefficients and reducing modulo 5.
- Multiplication is carried out by multiplying the polynomials and reducing modulo both 5 and the irreducible polynomial $f(x)$.

#+BEGIN_SRC sage :session . :exports both
F5=GF(5)

# ring of polynomials in F5
F5x.<x> = F5[]

# polynomial irreducible in F5 of degree m = 2
P_MOD_2 = F5x(x^2+2)
P_MOD_2.is_irreducible()

# define the extension field.
# a is the root of the irreducible polynomial
F5_2a.<a> = GF(5^2, name = 'a', modulus=P_MOD_2)
# this is 5^2 as expected
F5_2a.order()

# entire extended field (5^2 points)
[p for p in F5_2a]
#+END_SRC

#+RESULTS:
#+begin_example
True
25
[0,
 a + 4,
 3*a + 4,
 a,
 4*a + 3,
 4*a + 4,
 3,
 3*a + 2,
 4*a + 2,
 3*a,
 2*a + 4,
 2*a + 2,
 4,
 4*a + 1,
 2*a + 1,
 4*a,
 a + 2,
 a + 1,
 2,
 2*a + 3,
 a + 3,
 2*a,
 3*a + 1,
 3*a + 3,
 1]
#+end_example

** DONE Example: Visualizing the extension

The elements of \( \mathbb{F}_{23^2} \) are linear combinations $c_0 + c_1 \cdot a$, where $c_0, c_1 \in \mathbb{F}_{23}$, and $a$ is a root of the irreducible polynomial.

#+BEGIN_SRC sage :session . :exports both
q=23
Fq=GF(q)
E=EllipticCurve(Fq, [-1,0])

Fq2.<a> = GF(q^2, modulus='first_lexicographic') # let sage choose the modulus
Fq2.modulus()

Fq(3) + 2*a
Fq(5) - a
#+END_SRC

#+RESULTS:
: x^2 + 1
: 2*a + 3
: 22*a + 5

** IN-PROGRESS Example: Constructing the extension field $F_4=F_{2^2}$
1. Choose the prime $p=2$
   - the characteristic of the field is 2.
2. Determine the field size
   - the field size is $p^2=4$
3. Find an irreducible polynomial over $F_2$.
   - Consider $P(x) = x^2+x+1$. This polynomial is irreducible over $F_2$ meaning it has no roots in $F_2$ and hence it cannot be factored into polynomials of a lower degree over $F_2$. The easiest way to check that is to evaluate P(x) in all the elements of $F_2$:
     - $P(0)=1  \quad \text{mod 2}$
     - $P(1)=1 \quad \text{mod 2}$
   - $x$ denotes a root of $P$ in $F_4=F_{2^2}$. This implies that $x^2+x+1=0 \Longleftrightarrow x^2=1+x$ in $F_4$.
4. Construct the field $F_4=F_2[x], \hspace{.5em} x^2+x+1 =0$. The set $F_{2^2}$ contains all polynomials of degree lower than $2$ with coefficients in $F_2$. These elements are:
   - $\{ 0, 1, x, x + 1\}$
   - $x$ is the generator of the field extension and all elements can be expressed in terms of $x$.
5. TODO Addition in the field:
6. TODO Multiplication in the field:

#+BEGIN_SRC sage :session . :exports both
# a finite field
F2 = GF(2)
# define a ring of polynomials with coefficients in F2:
F2x.<x> = F2[]

P=F2x(x^2+x+1)
P.is_irreducible()

print('1) ---')

# Constructing $F_{2^2}$ by dividing all $Q \in F_2[x]$ by an irreducible P
F2_2.<x> = F2x.quotient(P)
F2_2
for i in F2_2: print(i)

print('2) ---')

F2_2.<x> = GF(2^2, name='x', modulus=P)
F2_2
for i in F2_2: print(i)

print('3) ---')

# below are not all of the F2[x] polynomials, but enough to arrive at all of the extension field elements:
F2x(x^3).quo_rem(P)[1]
F2x(x^2).quo_rem(P)[1]
F2x(x).quo_rem(P)[1]
F2x(0).quo_rem(P)[1]
F2x(1).quo_rem(P)[1]

print('4) ---')
# x is the root of the polynomial P in the field F_{2^2}=F_4
P(x)

print('5) ---')
# x, the root of the polynomial P, is the generator of the multiplicative group from the extension field
x
x^2
x^3
#+END_SRC

#+RESULTS:
#+begin_example
True
1) ---
Univariate Quotient Polynomial Ring in x over Finite Field of size 2 with modulus x^2 + x + 1
0
1
x
x + 1
2) ---
Finite Field in x of size 2^2
0
x
x + 1
1
3) ---
1
x + 1
x
0
1
4) ---
0
5) ---
x
x + 1
1
#+end_example
** IN-PROGRESS Example: Constructing the extension field $F_{3^2}$.
We start by choosing an irreducible polynomial of degree 2 with coefficients in $F_3$.
We try $P(t)=t^2+1$.

The fastest way to show that $P$ is irreducible is to just insert all elements from $F_3$ and see if the result is ever zero:
$P(0) = 0^2 + 1 = 1$
$P(1) = 1^2 + 1 = 2$
$P(2) = 2^2 + 1 = 1 + 1 = 2$

This implies that $P$ is irreducible, since all factors must be of the form $(t - a)$ for $a$ being a root of $P$.
The set $F_{3^2}$ contains all polynomials of degrees lower than 2, with coefficients in $F_{3}$:

$F_{3^2} = \{ 0, 1, 2, t, t + 1, t + 2, 2t, 2t + 1, 2t + 2 \}$

It has exactly $3^2$ elements.

=addition=
Addition is defined as addition of polynomials, for example:

$(t + 2) + (2t + 2) = (1 + 2)t + (2 + 2) = 1$

=multiplication=
TODO

* DONE Extending Elliptic Curves to prime field extensions
Suppose that $p$ is a prime number, and $F_p$ its associated prime field. We know from [[PrimeFieldExtension][Prime Field Extension]]
that the fields $F_{p^m}$ are extensions of $F_p$ in the sense that $F_p$ is a subfield of $F_{p^m}$.

This implies that we can extend the affine plane that an elliptic curve is defined on by changing the base field to any extension field.

Let $E(F) = \{(x, y) \in F \times F \hspace{0.5em} | \hspace{0.5em} y^2 = x^3 + a · x + b\}$

be an affine Short Weierstrass curve, with parameters $a$ and $b$ taken from $F$.
If $F'$ is an extension field of $F$, then we extend the domain of the curve by defining $E(F')$ as follows:

$E(F') = \{(x, y) \in F' \times F' \hspace{0.5em} | \hspace{0.5em} y^2 = x^3 + ax + b\}$

We did not change the defining parameters, but we consider curve points from the affine plane over the extension field now.

** Example
Consider prime field $F_5$ together with an elliptic curve $E_{1,1}(F_5)$.
We extend the definition of $E_{1,1}(F_5)$ to an elliptic curve over $F_{5^2}$ and compute it's set of points:

$E_{1,1}(F_{5^2}) = \{(x,y) \in F_{5^2} \times F_{5^2}\ \hspace{0.5em} | \hspace{0.5em} y^2 = x^3 + 1 + 1}$.

Since $F_{5^2}$ contains 25 points, we would have to try $25\cdot25=625$ pairs. Using Sage:

#+BEGIN_SRC sage :session . :exports both
F5=GF(5)

# ring of polynomials in F5
F5x.<x> = F5[]

# polynomial irreducible in F5 of degree m = 2
P_MOD_2 = F5x(x^2+2)
P_MOD_2.is_irreducible()

# define the extension field.
# a is the root of the irreducible polynomial
F5_2a.<a> = GF(5^2, name='a', modulus=P_MOD_2)

# define the elliptic curve in the extension field
E_F5_2=EllipticCurve(F5_2a, [1,1])
E_F5_2

E_F5_2.order()

E_F5_2.points()

#+END_SRC

#+RESULTS:
: True
: Elliptic Curve defined by y^2 = x^3 + x + 1 over Finite Field in a of size 5^2
: 27
: [(0 : 1 : 0), (0 : 1 : 1), (0 : 4 : 1), (1 : a : 1), (1 : 4*a : 1), (2 : 1 : 1), (2 : 4 : 1), (3 : 1 : 1), (3 : 4 : 1), (4 : 2 : 1), (4 : 3 : 1), (a + 3 : 2*a + 4 : 1), (a + 3 : 3*a + 1 : 1), (2*a + 1 : a + 1 : 1), (2*a + 1 : 4*a + 4 : 1), (2*a + 2 : a : 1), (2*a + 2 : 4*a : 1), (2*a + 3 : 2 : 1), (2*a + 3 : 3 : 1), (3*a + 1 : a + 4 : 1), (3*a + 1 : 4*a + 1 : 1), (3*a + 2 : a : 1), (3*a + 2 : 4*a : 1), (3*a + 3 : 2 : 1), (3*a + 3 : 3 : 1), (4*a + 3 : 2*a + 1 : 1), (4*a + 3 : 3*a + 4 : 1)]

* IN-PROGRESS Field extension towers
- [ ] https://hackmd.io/@jpw/bn254#Field-extension-towers

Extending $F_p$ for p = 21888242871839275222246405745257275088696311157297823662689037894645226208583 to $F_{p^{12}}$

# p = 36u^4 + 36u^3 + 24u^2 + 6u + 1, with u = v^3 and v = 1868033, BN curve: y^2 = x^3 + 3 over F_p

#+BEGIN_SRC sage :session . :exports both
# Prime field for BN254
n = 1868033
o = n**3
p = 36*o**4 + 36*o**3 + 24*o**2 + 6*o + 1
#p = 21888242871839275222246405745257275088696311157297823662689037894645226208583
Fp = GF(p)

## First extension: Fp^2 = Fp[u]/(u^2 + 1)

R.<x> = PolynomialRing(Fp)
alpha_poly = R(x^2 + 1)
# irreducible polynomial in Fp
alpha_poly.is_irreducible()
# --- NOTE --- #
# u^2 + 1 is an irreducible polynomial in Fp
#
# which is the same as saying that -1 is a quadratic non-residue in Fp (there is no u such that u^2 = -1 in Fp)
#
# (p-1)/2 numbers in GF(p) are quadratic residues so:
# q is a quadratic residue mod p if and only if q^{(p-1)/2} = 1 mod p.
#
# pow(a,b,c) returns a^b mod c
# --- END: NOTE --- #
print(f"-1 is a quadratic residue in F_{p}: {pow(-1, Integer((p-1)/2), p) == 1}")
Fp2 = Fp.extension(alpha_poly, 'u')
u = Fp2.gen()

## Second extension: Fp^6 = Fp^2[v] / (v^3 - zeta)

R2.<y> = PolynomialRing(Fp2)
zeta = 9 + u
beta_poly = R2(y^3 - zeta)
# --- NOTE
# zeta is not a quadratic residue in Fp^2 and not a cubic residue in Fp^2
#
# this condition on zeta is equivalent to saying that the polynomial (X^6 - zeta) is irreducible over Fp^2[X]
#
# --- END: NOTE
print(f"{zeta} is a quadratic residue in F_{p}: {pow(zeta, Integer((p-1)/2), p) == 1}")

# TODO: wtf?
R2(y^6 - zeta).is_irreducible()

Fp6 = Fp2.extension(beta_poly, 'v')
v = Fp6.gen()

## Final extension: Fp^12

R3.<z> = PolynomialRing(Fp6)
eta = v + 1  # Arbitrary choice, should be handled as needed
gamma_poly = R3(z^2 - eta)
Fp12 = Fp6.extension(gamma_poly, 'w')
w = Fp12.gen()

w^12 - 18*w^6 + 82
#+END_SRC

#+RESULTS:
: True
: -1 is a quadratic residue in F_65000549695646603732796438742359905742825358107623003571877145026864184071783: False
: u + 9 is a quadratic residue in F_65000549695646603732796438742359905742825358107623003571877145026864184071783: False
: False
: (6*u + 15)*v^2 + (15*u + 87)*v + 20*u + 163

** TODO Example: extending $F_{97}$ to $F_{{97}^{12}}$ using a tower of extensions
- p101 PairingsForBeginners
** TODO Example: extending $F_3$ to F_{3^6} using a tower of extensions
#+BEGIN_SRC sage :session . :exports both
q = 3
Fq = GF(q)
Fq

## First extension: F_{q^2}
#
## ring of polynomials with an indeterminate x
#Rx.<x> = PolynomialRing(Fq)
## indeterminate x is the ring generator
#Rx.gen()
#
## irreducible polynomial over Fq
#alpha_poly = Rx(x^2 + 1)
#alpha_poly.is_irreducible()
#Fq2 = Fq.extension(modulus = alpha_poly, name = 'x')
## x is the generator of Fq2
#x = Fq2.gen()
#
## all the elements of the field can be expressed in terms of alpha
#[p for p in Fq2]
## modulus polynomial is such that alpha is it's root in Fq2
#alpha_poly(alpha) == Fq2(0)
#
## Second extension: F_{q^6} over F_{q^2}
#Ry.<y> = PolynomialRing(Fq2)
#Ry
#
## TODO : irreducible polynomial over Fq2
#beta_poly = Ry(y^3 - y + 1)
#beta_poly.is_irreducible()
#Fq6 = Fq2.extension(beta_poly, 'y')
#y = Fq6.gen()
#
## Show elements of the final field extension
#example_elem = y^5 + x * y^2 + x
#print(f"Example element in F_{q^6}: {example_elem}")
#+END_SRC

* r-torsion point
=Definition=

A point $P$ on an elliptic curve $E(F_q)$ is called an *r-torsion point* if it satisfies:
$rP=\mathcal{O}$,

where:

- $r$ is some positive integer (often a prime number in cryptographic applications).
- $rP$ denotes the repeated addition of the point P to itself r times,
- $\mathcal{O}$ is the identity element (the [[*Point at infinity][Point at infinity]]).

In other words, P has finite order $r$ or less.
* r-torsion group $E(F_q)[r]$
=Definition=

Let $F$ be a finite field, $E(F)$ an elliptic curve of order $n$ and $r$ a factor of $n$.
The $r$-torsion group of the elliptic curve $E(F)$ is defined as the set:

$E(F)[r] := \{P \in E(F) \hspace{0.5em} | \hspace{0.5em} [r]P=\mathcal{O} \}$

where $[r]P$ is the [[*Elliptic Curve scalar multiplication][Elliptic Curve scalar multiplication]] with base $P$.

In another words the r-torsion group of an elliptic curve $E(F_q)$, where $F_q$ is a finite field with q elements is the set of all the points on the elliptic curve that have an order dividing $r$.

=Properties=

- *Group Structure* the r-torsion group $E[r]$ forms a finite abelian group under the addition operation defined on the elliptic curve.
- *Order of the Group*: The order (the number of elements) of the $E[r]$ can vary. Over a finite field $F_q$, the structure of $E[r]$ depends on r, q and the elliptic curve itself.
- *Connection to Field Size*: If $r$ divides $q − 1$, then there exist r-torsion points over $F_q$. Otherwise, the r-torsion group may only have the identity point $\mathcal{O}$.
- In the case where $r$ is a prime number, $E[r]$ is isomorphic to $\mathbb{Z}/r\mathbb{Z} \times \mathbb{Z}/r\mathbb{Z}$ over algebraically closed fields. This means that every r-torsion point can be represented as $aP + bQ$, where $P$ and $Q$ are points of exact order $r$ and $a, b \in \mathbb{Z}/r\mathbb{Z}$.
- If $F$ is any field with characteristic zero or prime to r, we have: $E[r] \cong Z_r \times Z_r$. This means that in general $\#E[r]=r^2$ (a remarkable result!).

** Example
Let's consider:

$E(F_{101}): \hspace{.5em} y^2 = x^3 + x + 1$

- Group order is 105
- By the Lagrange's theorem the points (and subgroups) over the base field will have their order in {1, 3, 5, 7, 15, 21, 35, 105}.
- To get a point of order r | 105, we simply multiply group generator G by the appropriate cofactor, which is: $h = \#E / r$.
- a point is "killed" (sent to infinity) when it is multiplied by it's order: $r \cdot (\#E / r) \cdot P = \mathcal{O}$
- Any point over the full [[file:arithmetics.org::*Algebraic closure][Algebraic closure]] $E(\bar {F_q})$ that is killed by $r$ is said to be in the r-torsion.

#+BEGIN_SRC sage :session . :exports both
F101 = GF(101)
E_F101 = EllipticCurve(F101, [F101(1), F101(1)])

E_F101
E_order=E_F101.order()
print(f"The order of E is:\n{E_order}\nFactorized:\n{E_order.factor()}")

# finding all group generators (points that have the same order as the group)
generators = []
for P in E_F101.points():
    if P.order() == E_order:
        generators.append(P)

print(f"Number of generators of E(F_101): {len(generators)}")

# print("List of generators:")
# for G in generators:
#    print(G)

G = E_F101(47,12)

print("---")

# point of order 1
105 * G # point at infinity

# point of order 3
(105/3) * G

# point of order 5
(105/5) * G

# point of order 21
(105/21) * G

# a point is "killed" (sent to infinity) when it is multiplied by it's order
((105/3) * G) * 3

print("---")

# Any point over the full closure $\bar{F_q}$ that is killed by r is said to be in the r-torsion
21 * E_F101(28,8)
21 * E_F101(55,65)

torsion_21 = []
for P in E_F101.points():
  if 21*P == E_F101(0,1,0):
    torsion_21.append(P)

print(f"Number of points in 21-torsion group of E(F_101): {len(torsion_21)}")

#for P in torsion_21:
#  print(P)

#+END_SRC

#+RESULTS:
#+begin_example
Elliptic Curve defined by y^2 = x^3 + x + 1 over Finite Field of size 101
The order of E is:
105
Factorized:
3 * 5 * 7
Number of generators of E(F_101): 48
---
(0 : 1 : 0)
(28 : 8 : 1)
(46 : 76 : 1)
(55 : 65 : 1)
(0 : 1 : 0)
---
(0 : 1 : 0)
(0 : 1 : 0)
Number of points in 21-torsion group of E(F_101): 21
#+end_example

* IN-PROGRESS Embedding degree
=Definition=

The embedding degree $k$ of an elliptic curve is the smallest positive integer such that the group of r-torsion points of the elliptic curve $E$ (i.e., the points $P \in E$ such that $rP = \mathcal{O}$) is contained within the finite field $\mathbb{F}_{q^k}$, where $r$ is a prime number dividing the order of the elliptic curve.

In other words, $k$ is the smallest integer for which the curve has enough points to map every possible interaction of its points into the finite field.

In yet another words, $k$ is the smallest integer for which the field $F_{q^k}$ contains all of the $r$-th roots of unity.

Relation to the [[*r-torsion group $E(F_{q^{k(r)}})\[r\]$ ("full" r-torsion group)][r-torsion group $E(F_{q^{k(r)}})[r]$ ("full" r-torsion group)]]

Embedding degree $k$ is the smallest integer such that:
$E(F_{p^k})[r]=E(\overline{F_p})[r]$

---
*NOTE*

- We note that the embedding degree is actually a function k(q, r) of q and r
- Embedding degree is used to distinguish elliptic curves with efficiently computable pairings.

---

=Mathematical definition=

Let $F$ be a finite field of order $|F| = q$, $E(F)$ an elliptic curve over $F$ of order $\# E(F)=n$ and let $r$ be a prime factor of $n$ ($r$ divides $n$, i.e. $n$ is the cofactor).
The embedding degree of $E(F)$ with respect to $r$ is the smallest integer $k$ such that the following equation holds:

$r \hspace{.5em} | \hspace{.5em} q^k -1$

($r$ divides $q^k -1$).

Another formulation of the above:

$q^k \equiv 1 \hspace{.5em} | \hspace{.5em} \(\text{mod} \hspace{.5em} r\)$

We write $k(r)$ for the embedding degree of $E(F)$ with respect to $r$.

---

*NOTE*

[[file:algebra.org::*Fermats Little Theorem][Fermats Little Theorem]]  implies that there always exists an embedding degree $k(r)$ for every elliptic curve.
and that any factor $r$ of the curve's order $n$, since $k = r - 1$, is always a solution to the congruency $q^k \equiv 1 \quad \text{( mod r )}$.
This implies that the remainder of the integer division of $q^{r-1} - 1$ by $r$ is $0$.

---

** TODO Example
# TODO: example that illustrates how k is the smallest integer for which the field F_q^k contains all r-th roots of unity
# - find the embedding degree
# - find all roots of unity in the extension fields with extension < r
* r-torsion group $E(F_{q^{k(r)}})[r]$ (the "full" r-torsion group)
=Definition=

Let $F_q$ be a prime field and let $E(F_q)$ be an elliptic curve of order $n$, such that $r$ is a factor of $n$, with the [[*Embedding degree][Embedding degree]] $k(r)$ and $r$-torsion group $E(F_q)[r]$.
For the prime power $q^{k(r)}$ the r-torsion group $E(F_q^{k(r)})$ is the *full r-torsion group* of that elliptic curve, and we write it as follows:

$E(F_{q^{k(r)}})[r] = \{P \in E(F_{q^{k(r)}}): \hspace{.5em} [r]P=\mathcal{O} \}$

---

*NOTE*

Any full r-torsion group contains $r + 1$ cyclic subgroups (for prime $r$) of order $r$ (see p51 PairingsForBeginners).

---

To find the full $r$-torsion group:

1. *Identify the base curve and field:*
   - Start with an elliptic curve $E$ defined over the base field $\mathbb{F}_q$.

2. *Determine the embedding degree $k$:*
   - This step helps establish the smallest field extension required for all r-torsion points to exist in $\mathbb{F}_{q^k}$.

3. *Extend the curve to $\mathbb{F}_{q^k}$:*
   - Define the elliptic curve over the extended field.

4. *Find the torsion points:*
   - Identify the points on the extended curve where $rP = \mathcal{O}$.
** Example 91 MoonMath: Finding full r-torsion group
#+BEGIN_SRC sage :session . :exports both
# p 103
F5=GF(5)

E11_F5=EllipticCurve(F5,[1,1])
#E11_F5
#E11_F5.order()

# finding a 3-torsion sub-group of the E11_F5
torsion_3=[]
for p in E11_F5.points():
  if 3*p == E11_F5(0):
    torsion_3.append(p)
# this is a subset of the full 3-torsion in the field extension that is defined below
len(torsion_3)
torsion_3

# embedding degree of 3: smallest k such that: 3 | 5^k -1
# k = r-1 as expected
for k in range(1,5):
  if 3.divides(5^k-1):
    print(k);break

# ring of polynomials in F5
F5x.<x> = F5[]
# irreducible polynomial of degree m = 2
P_MOD_2 = F5x(x^2+2)
P_MOD_2.is_irreducible()
# define the extension field
F5_2x.<x> = GF(5^2, name='x', modulus=P_MOD_2)

# now define the EC in the extension field (the curve extension)
E11_F5_2=EllipticCurve(F5_2x, [1,1])

#E11_F5_2.order()

# we now find the 3-torsion sub-group of the E11_F5_2:
# we know it to be the full 3-torsion group because the embedding degree k(r=3)=2, therefore the full 3-torsion will be in the
# F_q^2
torsion_3=[]
for p in E11_F5_2.points():
  if 3*p == E11_F5_2(0):
    torsion_3.append(p)

# there are 3^k(r)=3^2 elements in the 3-torsion group of the elliptic curve defined over the field extension (the full 3-torsion)
Integer(len(torsion_3)).factor()
torsion_3
#+END_SRC

#+RESULTS:
#+begin_example
3
[(0 : 1 : 0), (2 : 1 : 1), (2 : 4 : 1)]
2
True
3^2
[(0 : 1 : 0),
 (1 : x : 1),
 (1 : 4*x : 1),
 (2 : 1 : 1),
 (2 : 4 : 1),
 (2*x + 1 : x + 1 : 1),
 (2*x + 1 : 4*x + 4 : 1),
 (3*x + 1 : x + 4 : 1),
 (3*x + 1 : 4*x + 1 : 1)]
#+end_example

** Example 4.1.1 Pairings For Beginners: Finding full r-torsion group
#+BEGIN_SRC sage :session . :exports both
q=11
Fq=GF(q)
E_Fq=EllipticCurve(Fq, [0,4])
# EC group order is 12
E_Fq_order=E_Fq.order()
print(f"E_F{q} group order: {E_Fq_order}")

# so we take r=3
r=3

# define the 3-torsion
torsion_3=[P for P in E_Fq.points() if r * P == E_Fq(0)]
torsion_3
print(f"Number of points in {r}-torsion group of E_F{q}: {len(torsion_3)}")

# embedding degree
k = 1
while not (r.divides(q^k - 1)):
    k += 1
print(f"Embedding degree of E_F{q}: {k}")

# extension in F_q^k where we know the full r-torsion to be
# take the ring of polynomials with coefficients in Fq:
Fqx.<x> = Fq[]
# take a polynomial with no roots in Fq
P=Fqx(x^2+1)
P.is_irreducible()

Fq_k.<x> = GF(q^k, name='x', modulus=P)

# we now define the same EC in the extension field
E_Fq_k=EllipticCurve(Fq_k,[0,4])

full_torsion=[P for P in E_Fq_k if r*P == E_Fq_k(0)]
full_torsion
#+END_SRC

#+RESULTS:
#+begin_example
E_F11 group order: 12
[(0 : 1 : 0), (0 : 2 : 1), (0 : 9 : 1)]
Number of points in 3-torsion group of E_F11: 3
Embedding degree of E_F11: 2
True
[(0 : 1 : 0),
 (0 : 2 : 1),
 (0 : 9 : 1),
 (8 : x : 1),
 (8 : 10*x : 1),
 (2*x + 7 : x : 1),
 (2*x + 7 : 10*x : 1),
 (9*x + 7 : x : 1),
 (9*x + 7 : 10*x : 1)]
#+end_example

** Example 4.1.2 Pairings For Beginners
In the rare case that $r^2 \hspace{.5em} | \hspace{.5em} \#E$ it is possible that the entire r-torsion can be found over $E(F_q)$
#+BEGIN_SRC sage :session . :exports both
q=31
Fq=GF(q)

E_Fq=EllipticCurve(Fq, [0,13])

print(f"E_F{q} group order: {E_Fq.order()}")

r = 5   # Torsion order we're interested in

# r^2 | #E
print(f"r^2={r^2} divides #E_F{q}={E_Fq.order()}: {(r^2).divides(E_Fq.order())}")

# Determine the embedding degree k
k = 1
while not (r.divides(Fq.order() ^ k - 1)):
    k += 1

print(f"E_F{q} embedding degree for r={r}: {k}");

# find all the r-torsion points (full r-torsion) it is in E(F_q^k) = E(F_q)
r_torsion = [P for P in E_Fq.points() if r * P == E_Fq(0)]
print(f"E{r} torsion: {r_torsion}");
#+END_SRC

#+RESULTS:
: E_F31 group order: 25
: r^2=25 divides #E_F31=25: True
: E_F31 embedding degree for r=5: 1
: E5 torsion: [(0 : 1 : 0), (1 : 13 : 1), (1 : 18 : 1), (3 : 3 : 1), (3 : 28 : 1), (5 : 13 : 1), (5 : 18 : 1), (12 : 6 : 1), (12 : 25 : 1), (13 : 3 : 1), (13 : 28 : 1), (15 : 3 : 1), (15 : 28 : 1), (17 : 11 : 1), (17 : 20 : 1), (21 : 6 : 1), (21 : 25 : 1), (22 : 11 : 1), (22 : 20 : 1), (23 : 11 : 1), (23 : 20 : 1), (25 : 13 : 1), (25 : 18 : 1), (29 : 6 : 1), (29 : 25 : 1)]

* IN-PROGRESS [#A] ECDSA
** materials
- [ ] https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm
- [ ] Digital Signatures (chap 4) from An Introduction to Mathematical Cryptography
- [ ] Authentication and digital signatures from Cryptography Algorithms
- [ ] https://www.rareskills.io/post/ecdsa-tutorial
** IN-PROGRESS notes
- why?
- components
- EC discrete log
- two attempts at creating a scheme
 - differrent private and public parts
 - both lead to undersirable outcomes: one is underconstrained (Q can be picked at random, as the discrete log relation Q=qG is not veriofied)
 - another leads to revealing the private key p
- It turns out that proving we know the discrete log of two points without revealing them is easier than proving we know the discrete log of one point without revealing the single discrete log
- this protocol is interactive: Fiat-Shamir Transform to make it non-interactive

#+BEGIN_SRC sage :session . :exports both

# TODO P+O and P+(-P)
def add(P1,P2):
  x1=P1[0];x2=P2[0];y1=P1[1];y2=P2[1];
  lbda = (y2-y1) / (x2-x1);
  x3 = lbda^2 - x1 - x2
  return (x3, lbda*(x1 - x3) - y1);

def double(P,a):
  # doubling a point at infty = infty
  if ((P[0] == 0) and (P[1] == 1)):
    return (0, 1)
  # doubling a point of order 2 (tangent is vertical)
  if P[1] == 0:
    return (0, 1)
  x=P[0];y=P[1];
  lbda = (3*x^2 + a) / (2*y);
  x3 = lbda^2 - 2*x;
  return (x3,lbda*(x-x3) - y);

# double-and-add multiplication
def mult(n, P, a):
    Q = (0, 1)
    while n > 0:
        if n % 2 == 1:
            if Q == (0, 1):
                Q = P
            else:
                Q = add(Q, P)
        P = double(P, a)
        n = n // 2
    return Q

q=13
Fq = GF(q)
a=8;b=8
E_Fq = EllipticCurve(Fq, [a,b])
E_Fq

# enumerate all cyclic subgroups of E/F
subgroup_orders = {}
for P in E_Fq:
  r=P.order();
  subgroup_orders.setdefault(r, []).append(P)

print(f"All cyclic subgroups of {E_Fq} and their orders:")
subgroup_orders

#print(f"Prime order subgroups:")
# choose the biggest prime
r = max([x for x in filter(lambda x: is_prime(x), list(subgroup_orders.keys()))])

# scalar field (but actually a ring with prime order)
Fr=Integers(r)

P=E_Fq.random_point()
print(f"P={P}")

n = 6

#print(f"{n} * {P} = {n*P}")
#print(f"F{r}({n}) = {Fr(n)}, F{r}({n}) * {P} = {Fr(n) * P}")

(n)*P
mult(n, P, a)
#+END_SRC

#+RESULTS:
#+begin_example
Elliptic Curve defined by y^2 = x^3 + 8*x + 8 over Finite Field of size 13
All cyclic subgroups of Elliptic Curve defined by y^2 = x^3 + 8*x + 8 over Finite Field of size 13 and their orders:
{1: [(0 : 1 : 0)],
 10: [(1 : 2 : 1), (1 : 11 : 1), (5 : 2 : 1), (5 : 11 : 1)],
 2: [(4 : 0 : 1)],
 4: [(6 : 5 : 1), (6 : 8 : 1)],
 5: [(7 : 2 : 1), (7 : 11 : 1), (8 : 5 : 1), (8 : 8 : 1)],
 20: [(9 : 4 : 1),
  (9 : 9 : 1),
  (10 : 3 : 1),
  (10 : 10 : 1),
  (11 : 6 : 1),
  (11 : 7 : 1),
  (12 : 5 : 1),
  (12 : 8 : 1)]}
P=(12 : 5 : 1)
(5 : 11 : 1)
(5, 11)
#+end_example

* IN-PROGRESS Additional materials
- [ ] Attacks on ECC (also excellent introduction to ECs): https://github.com/elikaski/ECC_Attacks
- [ ] cofactor clearing: https://loup-vaillant.fr/tutorials/cofactor
- [X] https://www.youtube.com/watch?v=9TFEBuANioo
- field extension towers [0/2]:
  - [ ] https://hackmd.io/@benjaminion/bls12-381?ref=blog.lambdaclass.com#Field-extensions
  - [ ] https://blog.lambdaclass.com/how-we-implemented-the-bn254-ate-pairing-in-lambdaworks/
